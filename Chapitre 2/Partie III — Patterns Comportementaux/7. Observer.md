# 7. Observer

## Objectif

Permettre à des objets de **réagir automatiquement à des changements d’état** d’un autre objet sans créer de dépendance forte entre eux.
Le **pattern Observer** définit une **relation de notification un-à-plusieurs** entre un objet “observé” (le *subject*) et plusieurs “observateurs”.

---

## Définition et explication

Le **pattern Observer** (ou *observateur*) est un *pattern comportemental* qui permet à un objet (*sujet*) d’informer automatiquement plusieurs autres objets (*observateurs*) de tout changement d’état, sans connaître leur identité concrète.

> Il met en œuvre le principe de **faible couplage** : le sujet n’a pas besoin de savoir *qui* l’écoute, il se contente de diffuser un événement.

Ce modèle est au cœur des **systèmes d’événements**, des **interfaces utilisateur** et des **architectures réactives**.

---

## Problème à résoudre

Vous avez un objet dont l’état change (ex. : les points de vie d’un joueur).
Plusieurs autres objets doivent être informés (HUD, effets visuels, sons, IA ennemie...).
Sans Observer, on aurait tendance à **appeler directement** ces objets depuis le joueur :

```csharp
public class Joueur
{
    private HUD hud;
    private AudioManager audio;

    public void PrendreDegats(int montant)
    {
        hud.MettreAJourPV();
        audio.JouerEffet("Hit");
    }
}
```

Ce code crée un **fort couplage** : le joueur dépend de la HUD, de l’audio, etc.
Si on change la HUD, tout le code doit être modifié.

Le pattern **Observer** casse ce lien : le joueur *notifie un événement*, et les autres objets *s’abonnent librement* à cet événement.

---

## Structure du pattern

| Élément                    | Rôle                                                                                  |
| -------------------------- | ------------------------------------------------------------------------------------- |
| **Subject (Sujet)**        | L’objet observé : il maintient la liste des observateurs et envoie les notifications. |
| **Observer (Observateur)** | Interface ou classe recevant les notifications.                                       |
| **ConcreteSubject**        | Sujet concret (ex. : Joueur, ScoreManager, etc.).                                     |
| **ConcreteObserver**       | Observateur concret (ex. : HUD, AudioManager, etc.).                                  |

---

## Implémentation en C# (version classique)

### Interface de base

```csharp
public interface IObserver
{
    void MettreAJour(int nouveauPV);
}

public interface ISujet
{
    void Ajouter(IObserver obs);
    void Retirer(IObserver obs);
    void Notifier();
}
```

### Sujet concret

```csharp
public class Joueur : ISujet
{
    private List<IObserver> observateurs = new List<IObserver>();
    private int pointsDeVie = 100;

    public void PrendreDegats(int montant)
    {
        pointsDeVie -= montant;
        Notifier();
    }

    public void Ajouter(IObserver obs) => observateurs.Add(obs);
    public void Retirer(IObserver obs) => observateurs.Remove(obs);

    public void Notifier()
    {
        foreach (var obs in observateurs)
            obs.MettreAJour(pointsDeVie);
    }
}
```

### Observateurs concrets

```csharp
public class HUD : IObserver
{
    public void MettreAJour(int nouveauPV)
    {
        Console.WriteLine($"HUD mis à jour : {nouveauPV} PV restants.");
    }
}

public class AudioManager : IObserver
{
    public void MettreAJour(int nouveauPV)
    {
        Console.WriteLine("Effet sonore : le joueur est blessé !");
    }
}
```

### Utilisation

```csharp
Joueur joueur = new Joueur();
joueur.Ajouter(new HUD());
joueur.Ajouter(new AudioManager());

joueur.PrendreDegats(20);
```

**Sortie :**

```
HUD mis à jour : 80 PV restants.
Effet sonore : le joueur est blessé !
```

Le joueur ne connaît plus ni la HUD ni l’AudioManager : il notifie simplement ses abonnés.

---

## Implémentation moderne avec `event` et `delegate` en C#

C# fournit une solution native et élégante pour implémenter le pattern Observer via les **délégués** et les **événements**.

### Exemple :

```csharp
public class Joueur
{
    public event Action<int> OnPVChange; // Événement

    private int pointsDeVie = 100;

    public void PrendreDegats(int montant)
    {
        pointsDeVie -= montant;
        OnPVChange?.Invoke(pointsDeVie); // Notification
    }
}
```

### Observateurs :

```csharp
public class HUD
{
    public void MettreAJour(int pv)
    {
        Console.WriteLine($"[HUD] PV actuels : {pv}");
    }
}

public class AudioManager
{
    public void MettreAJour(int pv)
    {
        Console.WriteLine("[Audio] Effet : dommage reçu !");
    }
}
```

### Utilisation :

```csharp
var joueur = new Joueur();
var hud = new HUD();
var audio = new AudioManager();

// Abonnement
joueur.OnPVChange += hud.MettreAJour;
joueur.OnPVChange += audio.MettreAJour;

joueur.PrendreDegats(25);
```

**Sortie :**

```
[HUD] PV actuels : 75
[Audio] Effet : dommage reçu !
```

C’est une implémentation **propre, moderne et naturelle** en C#, parfaitement compatible avec Unity.

---

## Application dans Unity

Le pattern Observer est **fondamental dans Unity**, car tout le moteur repose sur ce principe :

* Les **Events Unity** (`UnityEvent`, `OnTriggerEnter`, `OnCollisionEnter`, etc.) suivent ce modèle.
* Les **systèmes d’UI**, **entrées utilisateur** et **réactions de gameplay** utilisent ce schéma.
* Les **délégués C#** sont fréquemment employés pour relier différents scripts sans couplage fort.

### Exemple Unity : notification de dégâts

```csharp
using UnityEngine;
using System;

public class Player : MonoBehaviour
{
    public event Action<int> OnHealthChanged;
    private int health = 100;

    public void TakeDamage(int amount)
    {
        health -= amount;
        OnHealthChanged?.Invoke(health);
    }
}
```

#### Observateurs

```csharp
public class HealthUI : MonoBehaviour
{
    public void UpdateHealth(int newHealth)
    {
        Debug.Log($"HUD : {newHealth} PV restants");
    }
}

public class AudioSystem : MonoBehaviour
{
    public void PlayDamageSound(int newHealth)
    {
        Debug.Log("Son de dégât joué !");
    }
}
```

#### Connexion dans Unity

```csharp
public class GameSetup : MonoBehaviour
{
    [SerializeField] private Player player;
    [SerializeField] private HealthUI hud;
    [SerializeField] private AudioSystem audioSystem;

    void Start()
    {
        player.OnHealthChanged += hud.UpdateHealth;
        player.OnHealthChanged += audioSystem.PlayDamageSound;
    }
}
```

Cette approche permet de **lier les systèmes au runtime**, sans dépendances rigides ni appels directs entre scripts.

---

## Avantages

1. **Découplage fort** : le sujet ne connaît pas ses observateurs.
2. **Extensibilité** : on peut ajouter ou retirer des observateurs à la volée.
3. **Réactivité** : permet de propager automatiquement des changements.
4. **Intégration native dans Unity** via les `events`, `UnityEvents` et `delegates`.

---

## Inconvénients

* Peut être difficile à **déboguer** si trop d’abonnements sont actifs.
* Risque de **fuites de mémoire** si les observateurs ne se désabonnent pas (`-= ...`).
* Si mal structuré, peut conduire à une **chaîne d’événements non contrôlée**.

---

## Bonnes pratiques

* Toujours **se désabonner** (`-=`) lors de la destruction d’un objet Unity (`OnDestroy`).
* Éviter les événements globaux non contrôlés.
* Documenter clairement les événements disponibles.
* Utiliser des **ScriptableObjects d’événements** (pattern *Event Channel*) pour les grands projets Unity.

---

## Quand utiliser le pattern Observer

| Situation                                              | Recommandation |
| ------------------------------------------------------ | -------------- |
| Plusieurs objets doivent réagir à un même événement    | ✅ Oui          |
| Vous voulez éviter les appels directs entre classes    | ✅ Oui          |
| Vous gérez des notifications UI, gameplay, audio, etc. | ✅ Oui          |
| Les dépendances sont simples et fixes                  | ❌ Inutile      |

---

## Résumé

| Aspect                    | Description                                                      |
| ------------------------- | ---------------------------------------------------------------- |
| **But**                   | Synchroniser plusieurs objets via des notifications d’événements |
| **Principe**              | Relation sujet-observateurs (un-à-plusieurs)                     |
| **Avantage clé**          | Faible couplage, haute extensibilité                             |
| **Exemple Unity typique** | UI santé, score, inventaire, notifications de gameplay           |

---

## Références utiles

* [Refactoring Guru — Observer Pattern](https://refactoring.guru/fr/design-patterns/observer)
* [Microsoft Learn — Events and Delegates in C#](https://learn.microsoft.com/fr-fr/dotnet/csharp/programming-guide/events/)
* [Unity Learn — Event-Driven Architecture](https://learn.unity.com/tutorial/events-and-delegates)
* Martin, Robert C. *Clean Architecture*, Prentice Hall, 2017 — chap. 8 : “Boundaries”.
