# 8. Strategy

## Objectif

Définir **une famille d’algorithmes interchangeables**, encapsuler chacun d’eux dans une classe distincte, et permettre au système de **choisir dynamiquement** lequel utiliser, **sans modifier le code client**.

---

## Définition et explication

Le **pattern Strategy** est un *pattern comportemental* qui consiste à **séparer un comportement variable du reste du code**.
L’idée est d’encapsuler plusieurs stratégies possibles dans des classes indépendantes, toutes basées sur une **même interface**, afin de pouvoir **changer le comportement à la volée**.

> En d’autres termes : *“On ne change pas la logique principale, on change la stratégie qu’elle emploie.”*

---

## Problème à résoudre

Imaginons un jeu où des ennemis ont plusieurs comportements possibles :

* agressif,
* défensif,
* aléatoire.

Une implémentation naïve serait d’utiliser des conditions partout :

```csharp
if (type == "agressif") { Attaquer(); }
else if (type == "defensif") { SeRetirer(); }
else if (type == "aleatoire") { FuirOuAttaquer(); }
```

Ce code est **rigide, non extensible et illisible**.
Chaque fois qu’un nouveau comportement est ajouté, il faut modifier la logique du système.

Le pattern **Strategy** résout ce problème en **isolant chaque comportement dans une classe distincte**, ce qui permet de les interchanger librement.

---

## Structure du pattern

| Élément                  | Rôle                                                  |
| ------------------------ | ----------------------------------------------------- |
| **Context**              | L’objet qui utilise une stratégie (ex. : Ennemi).     |
| **Strategy (interface)** | Définit l’interface commune de toutes les stratégies. |
| **ConcreteStrategy**     | Implémente un comportement spécifique.                |

---

## Implémentation en C#

### Interface de stratégie

```csharp
public interface IStrategieCombat
{
    void Executer();
}
```

### Stratégies concrètes

```csharp
public class StrategieAgressive : IStrategieCombat
{
    public void Executer() => Console.WriteLine("L’ennemi attaque violemment !");
}

public class StrategieDefensive : IStrategieCombat
{
    public void Executer() => Console.WriteLine("L’ennemi se met en position défensive.");
}

public class StrategieAleatoire : IStrategieCombat
{
    private Random rand = new Random();
    public void Executer()
    {
        if (rand.Next(0, 2) == 0)
            Console.WriteLine("L’ennemi attaque !");
        else
            Console.WriteLine("L’ennemi fuit !");
    }
}
```

### Contexte

```csharp
public class Ennemi
{
    private IStrategieCombat strategie;

    public Ennemi(IStrategieCombat strategie)
    {
        this.strategie = strategie;
    }

    public void ChangerStrategie(IStrategieCombat nouvelleStrategie)
    {
        strategie = nouvelleStrategie;
    }

    public void Agir()
    {
        strategie.Executer();
    }
}
```

### Utilisation

```csharp
Ennemi ennemi = new Ennemi(new StrategieAgressive());
ennemi.Agir();  // → "L’ennemi attaque violemment !"

ennemi.ChangerStrategie(new StrategieDefensive());
ennemi.Agir();  // → "L’ennemi se met en position défensive."
```

---

## Avantages

1. **Extensibilité** : ajouter une nouvelle stratégie ne nécessite pas de modifier le code existant.
2. **Lisibilité** : chaque comportement est isolé dans sa propre classe.
3. **Flexibilité** : le comportement peut être modifié à l’exécution.
4. **Respect du principe Open/Closed** : ouvert à l’extension, fermé à la modification.

---

## Inconvénients

* Multiplication du nombre de petites classes.
* Nécessite une **bonne gestion des dépendances** (injection ou instanciation claire).
* Pas idéal pour des comportements simples ou rarement modifiés.

---

## Application dans Unity

Dans Unity, le **Strategy Pattern** est très utilisé pour :

* les **IA d’ennemis** (stratégie de déplacement, de combat, de fuite, etc.),
* les **compétences de joueur** (attaque, soin, esquive, etc.),
* les **armes ou pouvoirs** (tir rapide, explosion, laser, etc.),
* les **systèmes de décision** (navigation, comportement d’alliés, etc.).

### Exemple Unity : IA d’ennemi

```csharp
using UnityEngine;

public interface IEnemyBehavior
{
    void Execute(Transform self, Transform target);
}

public class AggressiveBehavior : IEnemyBehavior
{
    public void Execute(Transform self, Transform target)
    {
        Debug.Log("L’ennemi fonce sur le joueur !");
        self.position = Vector3.MoveTowards(self.position, target.position, Time.deltaTime * 5);
    }
}

public class DefensiveBehavior : IEnemyBehavior
{
    public void Execute(Transform self, Transform target)
    {
        Debug.Log("L’ennemi se replie !");
        self.position = Vector3.MoveTowards(self.position, -target.position, Time.deltaTime * 3);
    }
}

public class RandomBehavior : IEnemyBehavior
{
    public void Execute(Transform self, Transform target)
    {
        if (Random.value > 0.5f)
            Debug.Log("Attaque surprise !");
        else
            Debug.Log("Fuite stratégique !");
    }
}
```

### Contexte (Ennemi)

```csharp
public class Enemy : MonoBehaviour
{
    private IEnemyBehavior behavior;
    [SerializeField] private Transform target;

    public void SetBehavior(IEnemyBehavior newBehavior)
    {
        behavior = newBehavior;
    }

    private void Update()
    {
        behavior?.Execute(transform, target);
    }
}
```

### Utilisation (dans un autre script)

```csharp
public class EnemySetup : MonoBehaviour
{
    [SerializeField] private Enemy enemy;

    void Start()
    {
        enemy.SetBehavior(new AggressiveBehavior());
    }

    void Update()
    {
        if (Input.GetKeyDown(KeyCode.Alpha1))
            enemy.SetBehavior(new AggressiveBehavior());
        if (Input.GetKeyDown(KeyCode.Alpha2))
            enemy.SetBehavior(new DefensiveBehavior());
        if (Input.GetKeyDown(KeyCode.Alpha3))
            enemy.SetBehavior(new RandomBehavior());
    }
}
```

L’ennemi peut ainsi **changer de comportement en temps réel** sans modifier sa logique interne.

---

## Comparaison avec d’autres patterns

| Pattern      | Objectif principal                                             |
| ------------ | -------------------------------------------------------------- |
| **Strategy** | Choisir dynamiquement un algorithme.                           |
| **State**    | Gérer un comportement dépendant d’un état interne.             |
| **Command**  | Encapsuler une action pour la stocker ou l’exécuter plus tard. |

Le *Strategy* se concentre sur **le choix d’une logique**, pas sur la gestion d’un état.

---

## Quand utiliser le Strategy Pattern

| Situation                                                     | Recommandation |
| ------------------------------------------------------------- | -------------- |
| Plusieurs variantes d’un même comportement existent           | ✅ Oui          |
| Le comportement doit être interchangeable à l’exécution       | ✅ Oui          |
| Le code contient beaucoup de conditions (`if/else`, `switch`) | ✅ Oui          |
| Les comportements sont simples et fixes                       | ❌ Inutile      |

---

## Résumé

| Aspect                    | Description                                                               |
| ------------------------- | ------------------------------------------------------------------------- |
| **But**                   | Permettre de choisir dynamiquement un comportement ou un algorithme       |
| **Principe**              | Encapsuler chaque stratégie dans une classe distincte                     |
| **Avantage clé**          | Extensibilité et faible couplage                                          |
| **Exemple Unity typique** | IA d’ennemi, stratégie d’attaque, type de projectile, comportement d’arme |

---

## Références utiles

* [Refactoring Guru — Strategy Pattern](https://refactoring.guru/fr/design-patterns/strategy)
* [Microsoft Learn — Behavioral Patterns](https://learn.microsoft.com/en-us/dotnet/architecture/grpc-for-wcf-developers/design-patterns)
* [Unity Learn — AI and Behavior Patterns](https://learn.unity.com/tutorial/ai-behaviour-and-state)
* Gamma et al. *Design Patterns: Elements of Reusable Object-Oriented Software*, Addison-Wesley, 1994.
