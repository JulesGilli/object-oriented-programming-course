# 9. State

## Objectif

Permettre à un objet de **modifier son comportement en fonction de son état interne**, comme s’il changeait de classe à l’exécution.
Chaque état est représenté par une classe distincte, et l’objet délègue ses actions à celle qui correspond à son état actuel.

---

## Définition et explication

Le **pattern State** (ou *État*) est un *pattern comportemental* qui permet de **remplacer les conditions `if/else` ou `switch` répétitives** par une **structure orientée objet**.
Au lieu de gérer les états via des drapeaux ou des variables (`if (etat == "Attaque")`...), on encapsule chaque état dans une classe dédiée.

> L’objet principal délègue son comportement à un “état courant”, qui peut être changé à tout moment.

Ce pattern est fondamental pour les systèmes **à logique évolutive** : personnages de jeux, machines à états, IA, interfaces utilisateur, etc.

---

## Problème à résoudre

Prenons un personnage de jeu qui peut être :

* au repos,
* en attaque,
* en fuite,
* mort.

Une approche naïve utiliserait un code rempli de conditions :

```csharp
if (etat == "Repos") { ... }
else if (etat == "Attaque") { ... }
else if (etat == "Fuite") { ... }
```

Ce type de code devient vite illisible et difficile à maintenir.
Chaque ajout de nouvel état nécessite de modifier tout le bloc `switch`.

Le pattern **State** permet de déléguer chaque comportement à **une classe d’état indépendante**, tout en gardant la logique principale claire et extensible.

---

## Structure du pattern

| Élément               | Rôle                                                            |
| --------------------- | --------------------------------------------------------------- |
| **Context**           | L’objet dont le comportement varie selon l’état (ex. : Joueur). |
| **State (interface)** | Définit les comportements possibles dans chaque état.           |
| **ConcreteState**     | Implémente le comportement pour un état spécifique.             |
| **Transition**        | Le contexte peut changer d’état à tout moment.                  |

---

## Implémentation en C#

### Interface d’état

```csharp
public interface IEtat
{
    void Entrer(Joueur joueur);
    void Executer(Joueur joueur);
    void Sortir(Joueur joueur);
}
```

### États concrets

```csharp
public class EtatRepos : IEtat
{
    public void Entrer(Joueur joueur) => Console.WriteLine("Le joueur se repose.");
    public void Executer(Joueur joueur) => Console.WriteLine("Zzz...");
    public void Sortir(Joueur joueur) => Console.WriteLine("Le joueur se réveille.");
}

public class EtatAttaque : IEtat
{
    public void Entrer(Joueur joueur) => Console.WriteLine("Le joueur se met en position d'attaque !");
    public void Executer(Joueur joueur) => Console.WriteLine("Le joueur attaque !");
    public void Sortir(Joueur joueur) => Console.WriteLine("Le joueur cesse d'attaquer.");
}
```

### Contexte

```csharp
public class Joueur
{
    private IEtat etatCourant;

    public void ChangerEtat(IEtat nouvelEtat)
    {
        etatCourant?.Sortir(this);
        etatCourant = nouvelEtat;
        etatCourant.Entrer(this);
    }

    public void MettreAJour()
    {
        etatCourant?.Executer(this);
    }
}
```

### Utilisation

```csharp
var joueur = new Joueur();

joueur.ChangerEtat(new EtatRepos());
joueur.MettreAJour();

joueur.ChangerEtat(new EtatAttaque());
joueur.MettreAJour();
```

**Sortie :**

```
Le joueur se repose.
Zzz...
Le joueur se met en position d'attaque !
Le joueur attaque !
```

---

## Avantages

1. **Lisibilité accrue** : plus de blocs `switch` ou `if/else` géants.
2. **Extensibilité** : ajouter un nouvel état ne casse pas le code existant.
3. **Encapsulation claire** : chaque état gère son propre comportement.
4. **Transitions explicites** : contrôle précis des changements d’état.

---

## Inconvénients

* Multiplication du nombre de classes (un état = une classe).
* Peut sembler verbeux pour des systèmes simples.
* Demande une **discipline de conception** pour bien gérer les transitions.

---

## Application dans Unity

Le **State Pattern** est extrêmement courant dans Unity, notamment pour :

* les **machines à états** de gameplay (menu, combat, pause, mort),
* les **comportements d’ennemis IA**,
* les **animations** (via `Animator` ou code),
* les **logiques de joueur** (saut, course, attaque, etc.).

### Exemple Unity : machine à états pour un personnage

```csharp
using UnityEngine;

public interface IPlayerState
{
    void Enter(Player player);
    void Execute(Player player);
    void Exit(Player player);
}

public class IdleState : IPlayerState
{
    public void Enter(Player player) => Debug.Log("Le joueur se met au repos.");
    public void Execute(Player player) => Debug.Log("Zzz...");
    public void Exit(Player player) => Debug.Log("Le joueur se prépare à bouger.");
}

public class AttackState : IPlayerState
{
    public void Enter(Player player) => Debug.Log("Le joueur prépare son attaque !");
    public void Execute(Player player) => Debug.Log("Coup porté !");
    public void Exit(Player player) => Debug.Log("Le joueur reprend sa garde.");
}

public class DeadState : IPlayerState
{
    public void Enter(Player player) => Debug.Log("Le joueur est mort !");
    public void Execute(Player player) { }
    public void Exit(Player player) => Debug.Log("Impossible : joueur mort.");
}
```

### Contexte (Player)

```csharp
public class Player : MonoBehaviour
{
    private IPlayerState currentState;

    void Start()
    {
        ChangeState(new IdleState());
    }

    void Update()
    {
        currentState?.Execute(this);
    }

    public void ChangeState(IPlayerState newState)
    {
        currentState?.Exit(this);
        currentState = newState;
        currentState.Enter(this);
    }
}
```

### Exemple d’utilisation dans Unity

```csharp
void Update()
{
    if (Input.GetKeyDown(KeyCode.A))
        ChangeState(new AttackState());
    if (Input.GetKeyDown(KeyCode.D))
        ChangeState(new DeadState());
}
```

Résultat dans la console :

```
Le joueur se met au repos.
Zzz...
Le joueur prépare son attaque !
Coup porté !
Le joueur est mort !
```

Chaque comportement est **isolé**, **remplaçable** et **testable indépendamment**.

---

## Différence entre *State* et *Strategy*

| Aspect                   | **State**                                       | **Strategy**                          |
| ------------------------ | ----------------------------------------------- | ------------------------------------- |
| Objectif                 | Gérer les transitions d’état interne d’un objet | Choisir dynamiquement un comportement |
| Changement               | Dépend de la logique du contexte                | Dépend d’une décision externe         |
| Exemple typique          | Joueur : repos → attaque → mort                 | IA : agressif / défensif / aléatoire  |
| Transition automatique ? | Oui                                             | Non                                   |

> En résumé :
> **Strategy** = “Choisir une manière d’agir.”
> **State** = “Changer de comportement en fonction de la situation.”

---

## Quand utiliser le State Pattern

| Situation                                                | Recommandation              |
| -------------------------------------------------------- | --------------------------- |
| Un objet possède plusieurs états internes distincts      | ✅ Oui                       |
| Son comportement varie selon l’état                      | ✅ Oui                       |
| Le code actuel contient beaucoup de conditions `if/else` | ✅ Oui                       |
| Le nombre d’états est faible et fixe                     | ⚠️ Peut être surdimensionné |

---

## Résumé

| Aspect                    | Description                                           |
| ------------------------- | ----------------------------------------------------- |
| **But**                   | Encapsuler des comportements selon des états internes |
| **Principe**              | Remplacer les `if/else` par des classes d’états       |
| **Avantage clé**          | Code extensible, clair et orienté objet               |
| **Exemple Unity typique** | Joueur, IA, systèmes de menus, machines à états       |

---

## Références utiles

* [Refactoring Guru — State Pattern](https://refactoring.guru/fr/design-patterns/state)
* [Microsoft Learn — Behavioral Patterns](https://learn.microsoft.com/en-us/dotnet/architecture/grpc-for-wcf-developers/design-patterns)
* [Unity Learn — Finite State Machines](https://learn.unity.com/tutorial/finite-state-machine)
* Freeman, Eric & Robson, Elisabeth. *Head First Design Patterns*, O’Reilly, 2021.
