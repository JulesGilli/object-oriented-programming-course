# 10. Command

## Objectif

Encapsuler une **action** ou une **opération** dans un objet distinct afin de pouvoir :

* l’exécuter plus tard,
* l’annuler (*undo*),
* la mettre en file d’attente,
* ou la combiner avec d’autres actions.

---

## Définition et explication

Le **pattern Command** est un *pattern comportemental* qui transforme une **demande** (une action, une instruction) en un **objet autonome**.
Cet objet contient :

* la **logique** de l’action à exécuter,
* et les **informations nécessaires** pour l’effectuer (cible, paramètres, etc.).

> Il découple **l’émetteur d’une commande** (ex. : une interface utilisateur, un système d’input) de **son exécuteur** (ex. : un joueur, un moteur d’actions).

---

## Problème à résoudre

Sans ce pattern, les actions utilisateur sont souvent exécutées directement :

```csharp
if (Input.GetKeyDown(KeyCode.Space))
    joueur.Sauter();
```

Ce code est simple, mais :

* il crée un **couplage fort** entre l’input et la logique du joueur,
* il empêche de **mémoriser, rejouer ou annuler** les actions,
* il rend le système **peu flexible** si de nouveaux contrôles apparaissent.

Le pattern **Command** isole ces actions dans des objets indépendants et réutilisables.

---

## Structure du pattern

| Élément                 | Rôle                                                      |
| ----------------------- | --------------------------------------------------------- |
| **Command (interface)** | Déclare une méthode d’exécution (`Execute`).              |
| **ConcreteCommand**     | Implémente une action concrète.                           |
| **Receiver**            | L’objet qui exécute réellement la commande.               |
| **Invoker**             | L’objet qui invoque la commande.                          |
| **Client**              | Configure les associations entre commandes et récepteurs. |

---

## Implémentation en C#

### Interface de commande

```csharp
public interface ICommand
{
    void Execute();
    void Undo();
}
```

### Récepteur

```csharp
public class Lumiere
{
    public void Allumer() => Console.WriteLine("Lumière allumée !");
    public void Eteindre() => Console.WriteLine("Lumière éteinte !");
}
```

### Commandes concrètes

```csharp
public class AllumerLumiere : ICommand
{
    private Lumiere lumiere;

    public AllumerLumiere(Lumiere lumiere)
    {
        this.lumiere = lumiere;
    }

    public void Execute() => lumiere.Allumer();
    public void Undo() => lumiere.Eteindre();
}

public class EteindreLumiere : ICommand
{
    private Lumiere lumiere;

    public EteindreLumiere(Lumiere lumiere)
    {
        this.lumiere = lumiere;
    }

    public void Execute() => lumiere.Eteindre();
    public void Undo() => lumiere.Allumer();
}
```

### Invocateur

```csharp
public class Interrupteur
{
    private ICommand commande;

    public void SetCommande(ICommand cmd)
    {
        commande = cmd;
    }

    public void Appuyer()
    {
        commande.Execute();
    }

    public void Annuler()
    {
        commande.Undo();
    }
}
```

### Utilisation

```csharp
var lumiere = new Lumiere();
var cmdAllumer = new AllumerLumiere(lumiere);
var cmdEteindre = new EteindreLumiere(lumiere);

var interrupteur = new Interrupteur();

interrupteur.SetCommande(cmdAllumer);
interrupteur.Appuyer();  // → Lumière allumée !
interrupteur.Annuler();  // → Lumière éteinte !

interrupteur.SetCommande(cmdEteindre);
interrupteur.Appuyer();  // → Lumière éteinte !
```

---

## Avantages

1. **Découplage complet** entre le demandeur et l’exécuteur de l’action.
2. **Stockage d’historique** des actions possible (Undo/Redo).
3. **Programmation flexible** (mise en file d’attente, macros, enregistrement).
4. **Réutilisation et composition** : on peut combiner plusieurs commandes.

---

## Inconvénients

* Nombre important de petites classes (une par commande).
* Complexité accrue si le système est volumineux.
* Requiert une gestion claire des dépendances et de l’historique.

---

## Application dans Unity

Le pattern **Command** est extrêmement utile dans Unity, notamment pour :

* la **gestion d’inputs** (actions utilisateur indépendantes du contrôleur),
* les **systèmes de macro-commandes** (enchaînements d’actions),
* les **systèmes Undo/Redo** dans des éditeurs ou outils,
* les **moteurs d’animation ou gameplay séquencés**.

### Exemple Unity : système d’input modulaire

```csharp
using UnityEngine;

public interface ICommand
{
    void Execute();
}

public class JumpCommand : ICommand
{
    private Player player;
    public JumpCommand(Player player) => this.player = player;
    public void Execute() => player.Jump();
}

public class AttackCommand : ICommand
{
    private Player player;
    public AttackCommand(Player player) => this.player = player;
    public void Execute() => player.Attack();
}

public class Player : MonoBehaviour
{
    public void Jump() => Debug.Log("Le joueur saute !");
    public void Attack() => Debug.Log("Le joueur attaque !");
}
```

### Invocateur : gestionnaire d’inputs

```csharp
public class InputHandler : MonoBehaviour
{
    private ICommand jumpCommand;
    private ICommand attackCommand;

    void Start()
    {
        var player = FindObjectOfType<Player>();
        jumpCommand = new JumpCommand(player);
        attackCommand = new AttackCommand(player);
    }

    void Update()
    {
        if (Input.GetKeyDown(KeyCode.Space))
            jumpCommand.Execute();

        if (Input.GetKeyDown(KeyCode.A))
            attackCommand.Execute();
    }
}
```

Résultat :

* Le système d’input est **découplé du joueur**.
* On peut changer les commandes sans modifier la logique du jeu.
* On peut **enregistrer**, **rejouer**, ou **annuler** les actions plus tard.

---

### Extension : historique des commandes (Undo/Redo)

```csharp
public class CommandManager
{
    private Stack<ICommand> historique = new Stack<ICommand>();

    public void ExecuterCommande(ICommand commande)
    {
        commande.Execute();
        historique.Push(commande);
    }

    public void AnnulerDerniereCommande()
    {
        if (historique.Count > 0)
        {
            var derniere = historique.Pop();
            derniere.Undo();
        }
    }
}
```

Ce gestionnaire permet d’ajouter très facilement un système d’**Undo/Redo**, par exemple dans un éditeur de niveau Unity.

---

## Quand utiliser le Command Pattern

| Situation                                                     | Recommandation |
| ------------------------------------------------------------- | -------------- |
| Vous voulez découpler l’émetteur de l’exécuteur d’une action  | ✅ Oui          |
| Vous avez besoin d’un système Undo/Redo                       | ✅ Oui          |
| Vous souhaitez enregistrer ou rejouer des actions utilisateur | ✅ Oui          |
| Vous avez peu d’actions simples et fixes                      | ❌ Inutile      |

---

## Comparaison avec d’autres patterns

| Pattern      | Objectif                               |
| ------------ | -------------------------------------- |
| **Observer** | Réagir à des événements.               |
| **Strategy** | Choisir un algorithme.                 |
| **Command**  | Encapsuler une action.                 |
| **State**    | Changer de comportement selon un état. |

---

## Résumé

| Aspect                    | Description                                                                        |
| ------------------------- | ---------------------------------------------------------------------------------- |
| **But**                   | Encapsuler des actions sous forme d’objets pour les exécuter, annuler ou planifier |
| **Principe**              | Découpler l’émetteur d’une commande de son exécuteur                               |
| **Avantage clé**          | Extensible, testable, compatible Undo/Redo                                         |
| **Exemple Unity typique** | Systèmes d’input, éditeurs, gameplay scripté                                       |

---

## Références utiles

* [Refactoring Guru — Command Pattern](https://refactoring.guru/fr/design-patterns/command)
* [Microsoft Learn — Command Design Pattern](https://learn.microsoft.com/en-us/previous-versions/msp-n-p/ff650316%28v=pandp.10%29)
* [Unity Learn — Input System and Command Patterns](https://learn.unity.com/tutorial/input-system)
* Freeman, Eric & Robson, Elisabeth. *Head First Design Patterns*, O’Reilly, 2021.
