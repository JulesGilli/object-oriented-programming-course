# 3. Builder

## Objectif

Permettre la **construction progressive et contrôlée** d’un objet complexe, sans exposer ses détails internes, et sans avoir à utiliser un constructeur comportant une longue liste de paramètres.

Le **Builder** sépare la **construction** d’un objet de sa **représentation**, ce qui permet de **réutiliser le même processus de création** pour produire différentes configurations d’objets.

---

## Définition et explication

Le **Builder** est un *pattern de création* utilisé lorsque :

* un objet comporte **de nombreux paramètres** (souvent optionnels),
* ou sa construction nécessite **plusieurs étapes successives**,
* ou encore lorsque différentes **variantes** d’un même type d’objet doivent être créées.

Ce patron **isole la logique de création** dans une classe distincte (le “constructeur d’objet”), appelée **Builder**.
L’objet final est assemblé étape par étape via une interface fluide et claire, souvent appelée **“fluent interface”**.

---

## Problème à résoudre

Sans le pattern Builder, on se retrouve souvent avec des **constructeurs longs et illisibles** :

```csharp
var joueur = new Joueur("Arthur", 100, 50, "Épée", true, false, "Guerrier", "Bois");
```

Ce type de constructeur est difficile à lire, à maintenir et à étendre.
De plus, la plupart de ces paramètres sont optionnels ou dépendent de conditions.

---

## Solution

Le pattern **Builder** propose de :

1. Décomposer la création d’un objet complexe en **étapes claires et successives**.
2. **Cacher** les détails internes de la construction.
3. **Retourner l’objet finalisé** via une méthode dédiée (`Build()` ou `GetResult()`).

Chaque appel configure une partie de l’objet, jusqu’à ce qu’il soit complet.

---

## Structure du pattern

| Élément                                    | Rôle                                                      |
| ------------------------------------------ | --------------------------------------------------------- |
| **Product (Produit)**                      | L’objet complexe à construire.                            |
| **Builder (Constructeur abstrait)**        | Définit les étapes de la construction.                    |
| **ConcreteBuilder (Constructeur concret)** | Implémente les étapes de création.                        |
| **Director (Optionnel)**                   | Ordonne les étapes de construction dans un certain ordre. |

---

## Implémentation en C#

### Exemple : création d’un personnage

```csharp
// Produit
public class Personnage
{
    public string Nom;
    public string Classe;
    public int Vie;
    public int Force;
    public string Arme;

    public override string ToString() =>
        $"{Nom} le {Classe} (PV: {Vie}, Force: {Force}) avec {Arme}";
}
```

### Builder abstrait

```csharp
public abstract class PersonnageBuilder
{
    protected Personnage personnage = new Personnage();

    public abstract void DefinirClasse();
    public abstract void DefinirStats();
    public abstract void DefinirArme();

    public Personnage GetResult() => personnage;
}
```

### Builders concrets

```csharp
public class GuerrierBuilder : PersonnageBuilder
{
    public override void DefinirClasse() => personnage.Classe = "Guerrier";
    public override void DefinirStats() { personnage.Vie = 150; personnage.Force = 20; }
    public override void DefinirArme() => personnage.Arme = "Épée";
}

public class ArcherBuilder : PersonnageBuilder
{
    public override void DefinirClasse() => personnage.Classe = "Archer";
    public override void DefinirStats() { personnage.Vie = 100; personnage.Force = 15; }
    public override void DefinirArme() => personnage.Arme = "Arc long";
}
```

### Directeur (optionnel)

```csharp
public class CreateurDePersonnage
{
    public Personnage Construire(PersonnageBuilder builder)
    {
        builder.DefinirClasse();
        builder.DefinirStats();
        builder.DefinirArme();
        return builder.GetResult();
    }
}
```

### Utilisation

```csharp
var createur = new CreateurDePersonnage();

Personnage guerrier = createur.Construire(new GuerrierBuilder());
Personnage archer = createur.Construire(new ArcherBuilder());

Console.WriteLine(guerrier);
Console.WriteLine(archer);
```

**Sortie :**

```
Guerrier le Guerrier (PV: 150, Force: 20) avec Épée
Archer le Archer (PV: 100, Force: 15) avec Arc long
```

---

## Variante : Fluent Builder (chaînage des appels)

C# permet une version plus fluide, très lisible :

```csharp
public class JoueurBuilder
{
    private Joueur joueur = new Joueur();

    public JoueurBuilder AvecNom(string nom)
    {
        joueur.Nom = nom;
        return this;
    }

    public JoueurBuilder AvecVie(int vie)
    {
        joueur.Vie = vie;
        return this;
    }

    public JoueurBuilder AvecArme(string arme)
    {
        joueur.Arme = arme;
        return this;
    }

    public Joueur Build() => joueur;
}

public class Joueur
{
    public string Nom;
    public int Vie;
    public string Arme;
    public override string ToString() => $"{Nom} ({Vie} PV) - Arme : {Arme}";
}
```

### Utilisation fluide :

```csharp
var joueur = new JoueurBuilder()
    .AvecNom("Arthur")
    .AvecVie(120)
    .AvecArme("Épée légendaire")
    .Build();

Console.WriteLine(joueur);
```

**Sortie :**

```
Arthur (120 PV) - Arme : Épée légendaire
```

Cette approche rend le code **expressif, lisible et extensible** — parfaite pour la configuration d’objets complexes.

---

## Application dans Unity

Le pattern Builder s’intègre naturellement dans Unity lorsqu’on souhaite :

* **configurer dynamiquement** des objets complexes (personnages, ennemis, armes, quêtes, etc.),
* **préparer des objets avant instanciation** (via des *ScriptableObjects* ou des *prefabs*),
* ou encore **créer des systèmes modulaires** de génération de personnages, de niveaux ou d’équipements.

### Exemple Unity : Construction d’un personnage

```csharp
public class PersonnageBuilder
{
    private GameObject prefab;
    private Vector3 position;
    private string nom;

    public PersonnageBuilder AvecPrefab(GameObject p)
    {
        prefab = p;
        return this;
    }

    public PersonnageBuilder ALaPosition(Vector3 pos)
    {
        position = pos;
        return this;
    }

    public PersonnageBuilder AvecNom(string n)
    {
        nom = n;
        return this;
    }

    public GameObject Build()
    {
        var go = Object.Instantiate(prefab, position, Quaternion.identity);
        go.name = nom;
        return go;
    }
}
```

### Utilisation :

```csharp
var personnage = new PersonnageBuilder()
    .AvecPrefab(prefabGuerrier)
    .ALaPosition(new Vector3(0, 0, 0))
    .AvecNom("Lancelot")
    .Build();
```

Ce modèle est particulièrement adapté à la **génération procédurale** ou à la **création de contenu dynamique**.

---

## Avantages

1. **Lisibilité accrue** : élimine les constructeurs complexes.
2. **Flexibilité** : permet de créer différentes variantes d’un même objet.
3. **Séparation des responsabilités** : la construction est isolée dans une classe dédiée.
4. **Contrôle total** : chaque étape de la création peut être personnalisée ou validée.
5. **Idéal pour l’immuabilité** : permet de construire des objets en lecture seule étape par étape.

---

## Inconvénients

* Légère complexité ajoutée pour les objets simples.
* Nécessite plusieurs classes (Builder, Produit, éventuellement Directeur).
* Peut sembler excessif si l’objet n’a que quelques paramètres.

---

## Quand utiliser le Builder

| Situation                                        | Recommandation |
| ------------------------------------------------ | -------------- |
| L’objet a beaucoup de paramètres optionnels      | ✅ Oui          |
| L’objet doit être construit étape par étape      | ✅ Oui          |
| Le processus de création est complexe            | ✅ Oui          |
| L’objet est simple (ex. : un `Vector3`)          | ❌ Inutile      |
| On veut des objets configurables via du chaînage | ✅ Oui          |

---

## Résumé

| Aspect                  | Description                                                 |
| ----------------------- | ----------------------------------------------------------- |
| **But**                 | Construire des objets complexes étape par étape             |
| **Principe**            | Séparer la construction de la représentation                |
| **Avantage**            | Code clair, modulaire, extensible                           |
| **Utilisation typique** | Configuration de personnages, objets, quêtes, niveaux, etc. |

---

## Références utiles

* [Refactoring Guru — Builder](https://refactoring.guru/fr/design-patterns/builder)
* [Microsoft Learn — Fluent Interfaces](https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/using-properties)
* [Unity Learn — Scriptable Objects and Data Architecture](https://learn.unity.com/tutorial/introduction-to-scriptable-objects)
* Freeman, Eric & Robson, Elisabeth. *Head First Design Patterns*, O’Reilly, 2021.
