# 2. Factory Method

## Objectif

Déléguer la **création d’objets** à des **sous-classes spécialisées** plutôt que d’instancier directement les classes dans le code.
Ce patron permet d’isoler la logique d’instanciation et de rendre le code **ouvert à l’extension**, mais **fermé à la modification** (principe *Open/Closed* du modèle SOLID).

---

## Définition et explication

Le **Factory Method** est un *pattern de création* qui définit **une interface de création d’objets**, tout en laissant aux classes dérivées le soin de **déterminer quel type concret** d’objet sera réellement instancié.

En d’autres termes, il s’agit d’une **“fabrique d’objets” polymorphe** :
le code client demande un objet sans connaître sa classe exacte, et la fabrique décide quel type créer.

### Problème à résoudre

Dans un code naïf, on a tendance à créer les objets directement :

```csharp
var ennemi = new Gobelin();
```

Mais cela **couple fortement** le code à une implémentation précise (`Gobelin`).
Si demain on ajoute un `Orc` ou un `Troll`, il faudra modifier toutes les parties du code qui instancient des ennemis.

### Solution

Définir une **interface ou classe abstraite** qui déclare une méthode de création (`CréerEnnemi()`), puis déléguer aux **sous-classes concrètes** la responsabilité d’instancier le bon type.

Le code client manipule uniquement l’interface abstraite — sans connaître la classe réelle créée.

---

## Structure du pattern

**Composants principaux :**

1. **Creator (créateur abstrait)** : définit la méthode de création d’objet (souvent `FactoryMethod()` ou similaire).
2. **ConcreteCreator (créateur concret)** : implémente la méthode de création pour produire un objet spécifique.
3. **Product (produit abstrait)** : définit l’interface commune des objets à créer.
4. **ConcreteProduct (produit concret)** : implémente le type d’objet réel.

---

## Implémentation en C#

### Exemple général

```csharp
// Produit abstrait
public abstract class Ennemi
{
    public abstract void Attaquer();
}

// Produits concrets
public class Gobelin : Ennemi
{
    public override void Attaquer() => Console.WriteLine("Le gobelin attaque !");
}

public class Troll : Ennemi
{
    public override void Attaquer() => Console.WriteLine("Le troll frappe avec sa massue !");
}

// Créateur abstrait
public abstract class FabriqueEnnemi
{
    public abstract Ennemi CreerEnnemi();
}

// Créateurs concrets
public class FabriqueGobelin : FabriqueEnnemi
{
    public override Ennemi CreerEnnemi() => new Gobelin();
}

public class FabriqueTroll : FabriqueEnnemi
{
    public override Ennemi CreerEnnemi() => new Troll();
}
```

### Utilisation

```csharp
FabriqueEnnemi fabrique = new FabriqueGobelin();
Ennemi ennemi = fabrique.CreerEnnemi();
ennemi.Attaquer();
```

**Sortie :**

```
Le gobelin attaque !
```

Le code client ne sait pas si l’ennemi est un Gobelin ou un Troll — il dépend uniquement de l’abstraction `Ennemi`.

---

## Avantages

1. **Découplage**

    * Le code client ne dépend plus des classes concrètes.
    * Ajout d’un nouveau type d’objet sans modifier le code existant.

2. **Extensibilité**

    * Facile d’ajouter de nouveaux “produits” en créant simplement une nouvelle fabrique.

3. **Cohérence de création**

    * Centralise la logique d’instanciation, utile pour contrôler ou valider la création d’objets.

4. **Polymorphisme**

    * Les objets créés partagent une interface commune, donc interchangeables dans le code client.

---

## Inconvénients

* Introduit **plus de classes** (une fabrique par type de produit).
* Peut paraître **complexe** pour des cas simples.
* Le choix du bon niveau d’abstraction demande de la **discipline de conception**.

---

## Application dans Unity

Le pattern Factory Method est **très utile dans Unity** pour la **création dynamique d’objets** (ennemis, projectiles, objets de jeu, etc.) sans dépendre d’un type concret.

### Exemple Unity : Générateur d’ennemis

```csharp
using UnityEngine;

public abstract class FabriqueEnnemi : MonoBehaviour
{
    public abstract GameObject CreerEnnemi(Vector3 position);
}

public class FabriqueGobelin : FabriqueEnnemi
{
    [SerializeField] private GameObject prefabGobelin;

    public override GameObject CreerEnnemi(Vector3 position)
    {
        return Instantiate(prefabGobelin, position, Quaternion.identity);
    }
}

public class FabriqueTroll : FabriqueEnnemi
{
    [SerializeField] private GameObject prefabTroll;

    public override GameObject CreerEnnemi(Vector3 position)
    {
        return Instantiate(prefabTroll, position, Quaternion.identity);
    }
}
```

Le code client :

```csharp
FabriqueEnnemi fabrique = GetComponent<FabriqueGobelin>();
fabrique.CreerEnnemi(new Vector3(0, 0, 0));
```

Ainsi, le système de génération d’ennemis est **ouvert à l’extension** (ajout de nouvelles fabriques) mais **fermé à la modification** du code principal.

---

## Comparaison : Factory Method vs new

| Approche       | Avantages                      | Inconvénients                    |
| -------------- | ------------------------------ | -------------------------------- |
| `new` direct   | Simple, rapide                 | Couplage fort, peu flexible      |
| Factory Method | Découplé, extensible, testable | Légère complexité supplémentaire |

---

## Quand utiliser le Factory Method

| Situation                                                      | Recommandation   |
| -------------------------------------------------------------- | ---------------- |
| Vous devez créer des objets dont le type concret peut varier   | ✅ Oui            |
| Vous voulez centraliser ou contrôler la création des instances | ✅ Oui            |
| Les objets sont simples et fixes                               | ❌ Pas nécessaire |
| Le projet nécessite une évolutivité (ajout futur de types)     | ✅ Oui            |

---

## Résumé

| Avantage principal  | Délégation de la création à des sous-classes                       |
| ------------------- | ------------------------------------------------------------------ |
| Objectif            | Découpler le code client de l’instanciation des objets             |
| Principe            | “Laissez les sous-classes décider du type d’objet à créer.”        |
| Utilisation typique | Génération d’ennemis, objets, projectiles, quêtes, etc. dans Unity |

---

## Références utiles

* [Refactoring Guru — Factory Method](https://refactoring.guru/fr/design-patterns/factory-method)
* [Microsoft Learn — Design Patterns in .NET](https://learn.microsoft.com/en-us/previous-versions/msp-n-p/ff650316%28v=pandp.10%29)
* Freeman, Eric & Robson, Elisabeth. *Head First Design Patterns*, O’Reilly, 2021.
* [Unity Learn — Object Management and Prefabs](https://learn.unity.com/tutorial/introduction-to-prefabs)
