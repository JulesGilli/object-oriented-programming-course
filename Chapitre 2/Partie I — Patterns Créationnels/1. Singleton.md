# 1. Le Singleton

## Objectif

Garantir qu’une **classe ne possède qu’une seule instance** dans le programme et fournir un **point d’accès global** à cette instance.

---

## Définition et explication

Le **Singleton** est un *pattern de création* qui s’assure qu’une classe donnée **ne soit instanciée qu’une seule fois** durant toute l’exécution du programme.
Il permet également de **centraliser l’accès** à cette instance unique.

Ce pattern est utile lorsqu’un seul objet doit coordonner les actions du système — par exemple, un gestionnaire d’état global, un système de son, un gestionnaire de score, ou un logger.

### Problème à résoudre

Certaines ressources ou comportements doivent être **uniques et accessibles de partout** :

* Le gestionnaire de jeu (GameManager)
* Le système de son (AudioManager)
* Le gestionnaire d’entrées ou de scènes
  Créer plusieurs instances de ces objets entraînerait des incohérences ou des conflits.

### Solution

Le Singleton encapsule la logique suivante :

1. **Empêcher la création directe** de nouvelles instances depuis l’extérieur.
2. **Conserver une instance unique** dans un membre statique privé.
3. **Fournir une méthode ou propriété d’accès** à cette instance.

---

## Implémentation en C# (version standard)

```csharp
public class GameManager
{
    private static GameManager instance;   // Instance unique
    private static readonly object verrou = new object(); // Sécurité multithread

    // Constructeur privé : empêche l’instanciation directe
    private GameManager() { }

    public static GameManager Instance
    {
        get
        {
            // Initialisation paresseuse (lazy initialization)
            if (instance == null)
            {
                lock (verrou)
                {
                    if (instance == null)
                        instance = new GameManager();
                }
            }
            return instance;
        }
    }

    public void LancerJeu()
    {
        Console.WriteLine("Le jeu démarre !");
    }
}
```

Utilisation :

```csharp
GameManager.Instance.LancerJeu();
```

Ici, peu importe combien de fois `GameManager.Instance` est appelée, **une seule instance** est créée et partagée.

---

## Caractéristiques principales

| Aspect                 | Description                                          |
| ---------------------- | ---------------------------------------------------- |
| **Portée**             | Globale : accessible depuis n’importe quelle classe. |
| **Nombre d’instances** | Une seule, créée à la demande.                       |
| **Contrôle d’accès**   | Le constructeur est `private`.                       |
| **Stockage**           | Instance conservée dans un champ `static`.           |

---

## Variante simplifiée (C# moderne)

Depuis C# 6, il est possible d’écrire un Singleton plus concis et thread-safe :

```csharp
public sealed class Logger
{
    private static readonly Logger instance = new Logger();

    public static Logger Instance => instance;

    private Logger() { }

    public void Log(string message)
    {
        Console.WriteLine($"[LOG] {message}");
    }
}
```

Utilisation :

```csharp
Logger.Instance.Log("Initialisation terminée");
```

Ici :

* `sealed` empêche l’héritage (bonne pratique pour un Singleton).
* L’initialisation statique garantit la sécurité et la simplicité.

---

## Implémentation dans Unity

Unity rend l’utilisation du Singleton particulièrement courante pour les **gestionnaires globaux** (audio, scène, UI, etc.).
Cependant, il faut adapter le modèle au cycle de vie des **GameObjects** et de **MonoBehaviour**.

### Exemple : Singleton Unity classique

```csharp
using UnityEngine;

public class GameManager : MonoBehaviour
{
    public static GameManager Instance { get; private set; }

    private void Awake()
    {
        if (Instance != null && Instance != this)
        {
            Destroy(gameObject); // Empêche les doublons
            return;
        }

        Instance = this;
        DontDestroyOnLoad(gameObject); // Persiste entre les scènes
    }

    public void DemarrerJeu()
    {
        Debug.Log("Le jeu commence !");
    }
}
```

Usage :

```csharp
GameManager.Instance.DemarrerJeu();
```

### Points importants :

* Le `MonoBehaviour` Singleton **ne peut pas être instancié avec `new`** : il doit exister dans la scène.
* `DontDestroyOnLoad()` empêche sa destruction lors d’un changement de scène.
* Le contrôle dans `Awake()` garantit l’unicité.

---

## Avantages du Singleton

1. **Instance unique garantie** — cohérence des données partagées.
2. **Accès global simplifié** — facile à utiliser depuis n’importe quel script.
3. **Contrôle centralisé** — utile pour les systèmes transversaux (gestion du son, sauvegarde, etc.).
4. **Économie de ressources** — pas besoin de recréer des objets redondants.

---

## Inconvénients et risques

1. **Couplage global** — les classes dépendant du Singleton deviennent difficilement testables.
2. **Risque d’abus** — tendance à en faire un “accès magique” pour tout, ce qui viole l’encapsulation.
3. **Cycle de vie difficile à contrôler** — surtout dans Unity si plusieurs scènes réinitialisent le Singleton.
4. **Dépendances cachées** — le code semble simple, mais introduit une forte dépendance implicite.

### Bonnes pratiques :

* Ne pas utiliser un Singleton pour tout : seulement pour des services globaux.
* Préférer l’**injection de dépendances** lorsque possible.
* Limiter les responsabilités du Singleton à **une seule fonction claire** (ex. : gestion audio, pas gameplay + UI + score).

---

## Exemple Unity typique

Exemples d’utilisation justifiée de Singletons dans Unity :

* `AudioManager` : gérer les effets sonores et musiques.
* `InputManager` : centraliser les entrées utilisateur.
* `GameManager` : suivre l’état global du jeu (score, niveau, pause).
* `SceneController` : gérer les transitions entre scènes.

```csharp
public class AudioManager : MonoBehaviour
{
    public static AudioManager Instance { get; private set; }
    public AudioSource musique;

    private void Awake()
    {
        if (Instance != null && Instance != this)
        {
            Destroy(gameObject);
            return;
        }

        Instance = this;
        DontDestroyOnLoad(gameObject);
    }

    public void JouerMusique()
    {
        musique.Play();
    }
}
```

---

## Quand utiliser le Singleton

| Situation                                                     | Singleton adapté ? |
| ------------------------------------------------------------- | ------------------ |
| Gestion d’un état global unique (son, score, configuration)   | ✅ Oui              |
| Objets temporaires ou multiples (ennemis, projectiles, items) | ❌ Non              |
| Partage de données entre scènes                               | ✅ Oui              |
| Gestion d’un comportement individuel                          | ❌ Non              |

---

## Résumé

| Avantages                             | Inconvénients                  |
| ------------------------------------- | ------------------------------ |
| Centralise un état global             | Crée du couplage fort          |
| Simplifie l’accès depuis tout le code | Cache les dépendances          |
| Garantit l’unicité                    | Difficile à tester ou étendre  |
| Idéal pour services globaux           | Mauvaise utilisation fréquente |

---

## Références utiles

* [Microsoft Learn — Design Patterns: Singleton](https://learn.microsoft.com/en-us/previous-versions/msp-n-p/ff650316%28v=pandp.10%29)
* [Refactoring Guru — Singleton Pattern](https://refactoring.guru/fr/design-patterns/singleton)
* [Unity Manual — Scripting Patterns](https://docs.unity3d.com/Manual/BestPracticeUnderstandingPerformanceInUnity4-1.html)
* Freeman, Eric & Robson, Elisabeth. *Head First Design Patterns*, O’Reilly, 2021.
