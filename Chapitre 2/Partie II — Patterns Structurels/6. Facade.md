# 6. Facade

## Objectif

Fournir une **interface unifiée et simplifiée** à un ensemble de classes ou de sous-systèmes complexes.
Le **pattern Facade** (ou *façade*) permet de **masquer la complexité interne** d’un système derrière une interface claire, cohérente et plus facile à utiliser.

---

## Définition et explication

Le **Facade** est un *pattern structurel* qui agit comme un **point d’entrée unique** vers un sous-système.
Il ne modifie pas la logique interne des classes qu’il encapsule — il se contente de **les coordonner** et de **simplifier leur utilisation**.

> L’objectif est de rendre un ensemble de fonctionnalités puissantes accessibles via une API simple et compréhensible.

---

## Problème à résoudre

Dans une application, on interagit souvent avec **plusieurs classes interdépendantes** :

* gérer l’audio,
* sauvegarder des données,
* charger une scène,
* configurer des paramètres.

Appeler toutes ces classes directement crée un **couplage fort** et **une grande complexité**.
Le pattern **Facade** permet de créer une **interface centrale** qui orchestre ces appels, simplifiant considérablement le code client.

---

## Structure du pattern

| Élément               | Rôle                                                                        |
| --------------------- | --------------------------------------------------------------------------- |
| **Subsystem classes** | Ensemble de classes complexes qui fournissent les fonctionnalités.          |
| **Facade**            | Interface simplifiée qui encapsule la complexité du sous-système.           |
| **Client**            | Code qui utilise la façade au lieu d’accéder directement aux sous-systèmes. |

---

## Implémentation en C#

### Exemple : gestion de jeu simplifiée

#### Sous-systèmes indépendants

```csharp
public class SystemeAudio
{
    public void JouerMusique() => Console.WriteLine("Musique de fond lancée...");
}

public class SystemeSauvegarde
{
    public void Sauvegarder() => Console.WriteLine("Partie sauvegardée !");
}

public class SystemeScene
{
    public void ChargerScene(string nom) => Console.WriteLine($"Scène '{nom}' chargée.");
}
```

#### Façade unifiée

```csharp
public class JeuFacade
{
    private SystemeAudio audio = new SystemeAudio();
    private SystemeSauvegarde sauvegarde = new SystemeSauvegarde();
    private SystemeScene scene = new SystemeScene();

    public void DemarrerJeu()
    {
        audio.JouerMusique();
        scene.ChargerScene("Niveau 1");
        Console.WriteLine("Le jeu est prêt !");
    }

    public void QuitterJeu()
    {
        sauvegarde.Sauvegarder();
        Console.WriteLine("Fermeture du jeu...");
    }
}
```

#### Utilisation

```csharp
var jeu = new JeuFacade();
jeu.DemarrerJeu();
jeu.QuitterJeu();
```

**Sortie :**

```
Musique de fond lancée...
Scène 'Niveau 1' chargée.
Le jeu est prêt !
Partie sauvegardée !
Fermeture du jeu...
```

Le client n’a plus besoin de connaître ni d’instancier les trois sous-systèmes :
la façade agit comme **interface simplifiée et point central d’accès**.

---

## Avantages

1. **Simplification de l’utilisation** : le client interagit avec une seule interface.
2. **Réduction du couplage** : le code client ne dépend plus des sous-systèmes internes.
3. **Organisation claire** : structure logique entre couches ou modules d’un projet.
4. **Encapsulation de la complexité** : permet d’évoluer sans impacter le code externe.

---

## Inconvénients

* Risque de créer un **“goulot d’étranglement”** si la façade devient trop lourde.
* Peut masquer la complexité **au détriment de la flexibilité**.
* Si mal conçue, elle peut **devenir un point de dépendance unique** (anti-pattern *God Object*).

---

## Application dans Unity

Dans Unity, le pattern **Facade** est très utile pour **organiser la communication entre systèmes** (audio, UI, inventaire, gameplay, etc.).
Il est souvent utilisé pour construire des **“Game Systems”** propres et bien isolés.

### Exemple Unity : gestionnaire de jeu (GameFacade)

```csharp
using UnityEngine;

public class AudioSystem : MonoBehaviour
{
    public void PlayMusic() => Debug.Log("Musique de fond lancée...");
}

public class SaveSystem : MonoBehaviour
{
    public void Save() => Debug.Log("Jeu sauvegardé !");
}

public class SceneSystem : MonoBehaviour
{
    public void LoadScene(string name) => Debug.Log($"Chargement de la scène {name}...");
}

public class GameFacade : MonoBehaviour
{
    [SerializeField] private AudioSystem audioSystem;
    [SerializeField] private SaveSystem saveSystem;
    [SerializeField] private SceneSystem sceneSystem;

    public void StartGame()
    {
        audioSystem.PlayMusic();
        sceneSystem.LoadScene("Niveau 1");
        Debug.Log("Jeu lancé !");
    }

    public void QuitGame()
    {
        saveSystem.Save();
        Debug.Log("Fermeture du jeu...");
    }
}
```

### Utilisation

```csharp
// Dans un script de menu principal :
public class MainMenu : MonoBehaviour
{
    [SerializeField] private GameFacade gameFacade;

    public void OnStartButton()
    {
        gameFacade.StartGame();
    }

    public void OnQuitButton()
    {
        gameFacade.QuitGame();
    }
}
```

Le **Menu** n’interagit plus directement avec les sous-systèmes : il ne connaît que la façade.
Cela améliore **l’isolation**, la **maintenance** et **les tests unitaires**.

---

## Bonnes pratiques

* Une façade doit **rester simple** : elle expose uniquement les fonctionnalités nécessaires.
* Si un système devient trop complexe, on peut le **diviser en plusieurs façades**.
* Coupler la façade à des **interfaces** pour permettre le remplacement ou la simulation des sous-systèmes (tests, prototypes, etc.).
* Utiliser ce pattern pour **structurer les couches logiques** d’un projet : UI → Gameplay → Système → Données.

---

## Quand utiliser le pattern Facade

| Situation                                                       | Recommandation |
| --------------------------------------------------------------- | -------------- |
| Le système est complexe et composé de nombreux modules          | ✅ Oui          |
| Le code client interagit directement avec trop de classes       | ✅ Oui          |
| Vous devez simplifier une API publique                          | ✅ Oui          |
| Vous voulez remplacer ou simuler un sous-système pour des tests | ✅ Oui          |
| Le système est simple ou unique                                 | ❌ Inutile      |

---

## Résumé

| Aspect              | Description                                                     |
| ------------------- | --------------------------------------------------------------- |
| **But**             | Fournir une interface simplifiée à un système complexe          |
| **Principe**        | Masquer la complexité derrière une API unique                   |
| **Bénéfices**       | Réduction du couplage, code client simplifié                    |
| **Exemple typique** | Gestionnaire global dans Unity (GameManager, AudioSystem, etc.) |

---

## Références utiles

* [Refactoring Guru — Facade Pattern](https://refactoring.guru/fr/design-patterns/facade)
* [Microsoft Learn — Structural Patterns](https://learn.microsoft.com/en-us/dotnet/architecture/grpc-for-wcf-developers/design-patterns)
* [Unity Manual — Architecture de projet et systèmes](https://docs.unity3d.com/Manual/BestPracticeUnderstandingPerformanceInUnity4-1.html)
* Freeman, Eric & Robson, Elisabeth. *Head First Design Patterns*, O’Reilly, 2021.
