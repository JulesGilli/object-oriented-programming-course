# 5. Decorator

## Objectif

Permettre d’**ajouter dynamiquement des comportements** à un objet **sans modifier son code** ni créer de sous-classes supplémentaires.
Le **Decorator** étend les fonctionnalités d’un objet de manière flexible et modulable.

---

## Définition et explication

Le **pattern Decorator** (ou *Décorateur*) est un *pattern structurel* qui consiste à **envelopper** un objet dans un autre objet afin d’en modifier ou enrichir le comportement.
L’idée est de composer plusieurs objets qui implémentent la même interface, chacun ajoutant une fonctionnalité particulière.

> Ce pattern favorise la **composition dynamique** plutôt que l’héritage statique.

C’est une excellente alternative à l’héritage lorsqu’on veut **combiner plusieurs comportements** à la volée, sans multiplier les classes dérivées.

---

## Problème à résoudre

Supposons que vous ayez une classe `Attaque` de base, et que vous souhaitiez ajouter différents effets :

* feu,
* poison,
* ralentissement,
* critique, etc.

Créer une classe pour chaque combinaison (`AttaqueFeu`, `AttaqueFeuEtPoison`, `AttaquePoisonEtCritique`, etc.) conduirait à une **explosion du nombre de sous-classes**.

Le pattern Decorator résout ce problème en **empilant dynamiquement des couches de comportement** autour d’un objet.

---

## Structure du pattern

| Élément                   | Rôle                                                                                             |
| ------------------------- | ------------------------------------------------------------------------------------------------ |
| **Component (Composant)** | Interface commune à tous les objets pouvant être décorés.                                        |
| **ConcreteComponent**     | Objet de base que l’on veut étendre.                                                             |
| **Decorator**             | Classe abstraite qui implémente la même interface et contient une référence vers un `Component`. |
| **ConcreteDecorator**     | Classe concrète qui ajoute un comportement supplémentaire.                                       |

---

## Implémentation en C#

### Exemple : système d’attaque avec effets

#### Interface de base

```csharp
public interface IAttaque
{
    void Executer();
}
```

#### Composant de base

```csharp
public class AttaqueDeBase : IAttaque
{
    public void Executer()
    {
        Console.WriteLine("Attaque simple !");
    }
}
```

#### Classe décoratrice abstraite

```csharp
public abstract class AttaqueDecorator : IAttaque
{
    protected IAttaque attaque;

    public AttaqueDecorator(IAttaque attaque)
    {
        this.attaque = attaque;
    }

    public virtual void Executer()
    {
        attaque.Executer();
    }
}
```

#### Décorateurs concrets

```csharp
public class AttaqueFeu : AttaqueDecorator
{
    public AttaqueFeu(IAttaque attaque) : base(attaque) { }

    public override void Executer()
    {
        base.Executer();
        Console.WriteLine("→ Effet de feu brûlant !");
    }
}

public class AttaquePoison : AttaqueDecorator
{
    public AttaquePoison(IAttaque attaque) : base(attaque) { }

    public override void Executer()
    {
        base.Executer();
        Console.WriteLine("→ L’ennemi est empoisonné !");
    }
}
```

#### Utilisation

```csharp
IAttaque attaque = new AttaqueDeBase();
attaque = new AttaqueFeu(attaque);
attaque = new AttaquePoison(attaque);

attaque.Executer();
```

**Sortie :**

```
Attaque simple !
→ Effet de feu brûlant !
→ L’ennemi est empoisonné !
```

Chaque décorateur ajoute son propre effet **sans altérer** le comportement du composant original.

---

## Avantages

1. **Flexibilité extrême** : on peut combiner plusieurs décorateurs dynamiquement.
2. **Pas de modification du code existant** : respecte le principe *Open/Closed*.
3. **Substitution transparente** : tous les objets partagent la même interface.
4. **Réutilisation du code** : les décorateurs sont indépendants les uns des autres.

---

## Inconvénients

* Complexité accrue si les décorateurs sont nombreux.
* L’ordre d’application peut influer sur le comportement.
* Plus difficile à déboguer (chaînes d’appels imbriquées).

---

## Application dans Unity

Dans Unity, le **Decorator** est particulièrement utile pour enrichir des comportements sans créer de hiérarchies complexes.
On peut l’utiliser pour :

* Ajouter des **effets temporaires** (bonus, debuffs, power-ups).
* Étendre des systèmes (attaques, IA, interactions).
* Gérer des **chaînes de traitement** (par exemple, filtres de dégâts ou effets visuels).

### Exemple Unity : système d’effets sur attaques

```csharp
public interface IAttack
{
    void Execute();
}

public class BasicAttack : IAttack
{
    public void Execute()
    {
        Debug.Log("Attaque de base !");
    }
}

public abstract class AttackDecorator : IAttack
{
    protected IAttack attack;
    public AttackDecorator(IAttack attack) => this.attack = attack;

    public virtual void Execute() => attack.Execute();
}

public class FireAttack : AttackDecorator
{
    public FireAttack(IAttack attack) : base(attack) { }

    public override void Execute()
    {
        base.Execute();
        Debug.Log("Effet de feu appliqué !");
    }
}

public class IceAttack : AttackDecorator
{
    public IceAttack(IAttack attack) : base(attack) { }

    public override void Execute()
    {
        base.Execute();
        Debug.Log("Effet de glace appliqué !");
    }
}
```

### Utilisation dans Unity

```csharp
IAttack attack = new BasicAttack();
attack = new FireAttack(attack);
attack = new IceAttack(attack);

attack.Execute();
```

**Console Unity :**

```
Attaque de base !
Effet de feu appliqué !
Effet de glace appliqué !
```

L’avantage : on peut combiner librement des effets sans créer des dizaines de classes dérivées comme `FireAndIceAttack`, `PoisonAndCritAttack`, etc.

---

## Quand utiliser le Decorator

| Situation                                                                | Recommandation |
| ------------------------------------------------------------------------ | -------------- |
| Vous devez ajouter des fonctionnalités à un objet sans modifier son code | ✅ Oui          |
| Vous voulez éviter une explosion de sous-classes                         | ✅ Oui          |
| Vous avez besoin de combiner plusieurs comportements dynamiquement       | ✅ Oui          |
| Le comportement ne varie jamais                                          | ❌ Inutile      |

---

## Comparaison : Héritage vs Décoration

| Approche       | Avantage             | Limite                 |
| -------------- | -------------------- | ---------------------- |
| **Héritage**   | Simple à implémenter | Rigide, peu flexible   |
| **Décorateur** | Dynamique, modulaire | Plus complexe à suivre |

---

## Résumé

| Aspect              | Description                                                       |
| ------------------- | ----------------------------------------------------------------- |
| **But**             | Ajouter dynamiquement des fonctionnalités à un objet              |
| **Principe**        | Envelopper l’objet d’autres objets implémentant la même interface |
| **Mot-clé**         | “Composition dynamique plutôt qu’héritage”                        |
| **Exemple typique** | Effets sur attaque, filtres, bonus temporaires                    |

---

## Références utiles

* [Refactoring Guru — Decorator Pattern](https://refactoring.guru/fr/design-patterns/decorator)
* [Microsoft Learn — Structural Patterns in .NET](https://learn.microsoft.com/en-us/dotnet/architecture/grpc-for-wcf-developers/design-patterns)
* [Unity Manual — Component-based Design](https://docs.unity3d.com/Manual/Components.html)
* Freeman, Eric & Robson, Elisabeth. *Head First Design Patterns*, O’Reilly, 2021.
