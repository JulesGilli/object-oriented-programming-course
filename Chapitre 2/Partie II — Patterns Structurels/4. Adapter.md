# 4. Adapter

## Objectif

Permettre à **deux classes incompatibles** de collaborer en **convertissant l’interface** de l’une en une interface que l’autre attend.
En d’autres termes, le pattern **Adapter** agit comme un **pont** entre deux systèmes qui ne parlent pas le même “langage”.

---

## Définition et explication

Le **pattern Adapter** (ou *Wrapper*) est un *pattern structurel* qui permet à des classes ayant des **interfaces différentes mais des fonctionnalités compatibles** de travailler ensemble.
Il **traduit** ou **adapte** l’interface d’une classe existante pour qu’elle soit compatible avec une autre interface attendue.

> L’adaptateur ne change pas le comportement interne des classes ; il se contente de les faire “communiquer”.

---

## Problème à résoudre

Imaginons que vous développiez un système de jeu qui attend une méthode `Deplacer()`, mais que vous disposiez d’une ancienne classe externe qui ne propose que `MoveTo()`.
Les interfaces sont différentes, mais le but est le même.

Modifier la classe existante n’est pas possible (parce qu’elle appartient à une bibliothèque tierce, ou qu’elle est utilisée ailleurs).
Le pattern Adapter résout ce problème en **créant une classe intermédiaire** qui traduit les appels.

---

## Structure du pattern

| Élément               | Rôle                                                                   |
| --------------------- | ---------------------------------------------------------------------- |
| **Client**            | Le code qui veut utiliser une fonctionnalité via une interface donnée. |
| **Target (Cible)**    | L’interface attendue par le client.                                    |
| **Adaptee (Adaptée)** | La classe existante à adapter (incompatible).                          |
| **Adapter**           | La classe intermédiaire qui fait le lien entre les deux.               |

---

## Implémentation en C#

### Exemple : adaptation de méthodes de mouvement

#### Classe existante (incompatible)

```csharp
public class SystemeDeDeplacement
{
    public void MoveTo(float x, float y)
    {
        Console.WriteLine($"Déplacement vers X:{x}, Y:{y}");
    }
}
```

#### Interface attendue

```csharp
public interface IDeplacable
{
    void Deplacer(float x, float y);
}
```

#### Adaptateur

```csharp
public class DeplacementAdapter : IDeplacable
{
    private SystemeDeDeplacement systeme;

    public DeplacementAdapter(SystemeDeDeplacement systeme)
    {
        this.systeme = systeme;
    }

    public void Deplacer(float x, float y)
    {
        // Adapte la méthode MoveTo() à l’interface attendue
        systeme.MoveTo(x, y);
    }
}
```

#### Utilisation

```csharp
SystemeDeDeplacement systeme = new SystemeDeDeplacement();
IDeplacable joueur = new DeplacementAdapter(systeme);

joueur.Deplacer(10, 20);
```

**Sortie :**

```
Déplacement vers X:10, Y:20
```

Le client (`joueur`) pense utiliser un objet `IDeplacable`, mais en réalité, il communique avec un `SystemeDeDeplacement` via un adaptateur.

---

## Types d’adaptateurs

### 1. **Adaptateur d’objet (composition)**

L’adaptateur **contient** une instance de la classe à adapter (comme dans l’exemple ci-dessus).
➡️ C’est la méthode la plus flexible et la plus utilisée en C# et Unity.

### 2. **Adaptateur de classe (héritage)**

L’adaptateur **hérite** à la fois de la classe à adapter et de l’interface cible.
➡️ Moins courant en C#, car il ne permet pas d’adapter plusieurs classes à la fois (héritage simple).

---

## Avantages

1. **Réutilisation du code existant** sans le modifier.
2. **Découplage** entre les systèmes : aucune dépendance directe à la classe originale.
3. **Compatibilité ascendante** : facilite l’intégration de bibliothèques externes.
4. **Souplesse** : un adaptateur peut être remplacé sans impact sur le code client.

---

## Inconvénients

* Introduit une **couche d’indirection** supplémentaire (léger coût en performance).
* Peut complexifier la structure s’il y a trop de niveaux d’adaptation.
* Doit être bien documenté pour éviter les confusions dans les grandes bases de code.

---

## Application dans Unity

Dans Unity, le pattern **Adapter** est particulièrement utile lorsqu’on veut **unifier plusieurs systèmes hétérogènes** :

* Adapter des **anciens scripts** à un nouveau système de gameplay.
* Connecter des **composants tiers** (comme une API, un SDK, un plugin externe).
* Simplifier des interfaces Unity en les encapsulant dans des classes plus cohérentes.

### Exemple Unity : adaptation d’un système de mouvement externe

```csharp
public class OldMovementSystem
{
    public void MoveToPosition(Vector3 pos)
    {
        Debug.Log($"Déplacement vers {pos}");
    }
}

public interface IMovable
{
    void Move(Vector3 destination);
}

public class MovementAdapter : IMovable
{
    private OldMovementSystem oldSystem;

    public MovementAdapter(OldMovementSystem system)
    {
        oldSystem = system;
    }

    public void Move(Vector3 destination)
    {
        oldSystem.MoveToPosition(destination);
    }
}
```

### Utilisation

```csharp
IMovable player = new MovementAdapter(new OldMovementSystem());
player.Move(new Vector3(2, 0, 5));
```

Grâce à l’adaptateur, on peut réutiliser `OldMovementSystem` sans le modifier, tout en respectant l’interface attendue (`IMovable`).

---

## Quand utiliser le pattern Adapter

| Situation                                                                          | Recommandation |
| ---------------------------------------------------------------------------------- | -------------- |
| Vous devez utiliser une classe dont l’interface ne correspond pas à celle attendue | ✅ Oui          |
| Vous intégrez une bibliothèque externe ou un ancien système                        | ✅ Oui          |
| Vous pouvez modifier la classe d’origine                                           | ❌ Inutile      |
| Vous avez besoin d’uniformiser plusieurs API différentes                           | ✅ Oui          |

---

## Résumé

| Aspect                  | Description                                                                   |
| ----------------------- | ----------------------------------------------------------------------------- |
| **But**                 | Faire collaborer des classes aux interfaces incompatibles                     |
| **Principe**            | Convertir l’interface d’une classe en une autre interface attendue            |
| **Type principal**      | Adaptateur d’objet (via composition)                                          |
| **Utilisation typique** | Migration de code, intégration de systèmes externes, compatibilité ascendante |

---

## Références utiles

* [Refactoring Guru — Adapter Pattern](https://refactoring.guru/fr/design-patterns/adapter)
* [Microsoft Learn — Structural Patterns in .NET](https://learn.microsoft.com/en-us/dotnet/architecture/grpc-for-wcf-developers/design-patterns)
* Freeman, Eric & Robson, Elisabeth. *Head First Design Patterns*, O’Reilly, 2021.
* [Unity Learn — Interfaces and Abstraction](https://learn.unity.com/tutorial/interfaces-and-abstract-classes)
