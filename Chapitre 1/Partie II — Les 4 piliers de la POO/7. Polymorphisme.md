# 7. Polymorphisme

## Objectif

Comprendre le principe du **polymorphisme** en programmation orientée objet, ses différentes formes (surcharge et redéfinition), et son rôle central dans la flexibilité et l’extensibilité du code orienté objet.

---

## Définition et explication

Le terme **polymorphisme** vient du grec *polymorphos*, signifiant “plusieurs formes”.
En programmation orientée objet, il désigne la **capacité d’un même symbole (méthode, référence, interface)** à **prendre plusieurs formes selon le contexte**.

Autrement dit, **un même appel de méthode** peut produire des **comportements différents** selon le type réel de l’objet sur lequel il agit.

Le polymorphisme permet d’écrire du code **générique et extensible**, capable de manipuler différents types d’objets via une **interface commune**, sans connaître leur implémentation concrète.

Exemple conceptuel :

> Un personnage du jeu peut attaquer. Qu’il s’agisse d’un `Guerrier`, d’un `Mage` ou d’un `Archer`, l’action “Attaquer” existe toujours, mais son exécution diffère selon la classe.

---

## Les deux formes principales de polymorphisme en C#

### 1. Le polymorphisme statique (ou *surcharge*)

Il se produit **à la compilation**, lorsque plusieurs méthodes partagent le même nom mais diffèrent par leur **signature** (nombre ou type de paramètres).
Le compilateur choisit la version appropriée selon les arguments passés.

```csharp
public class Calculatrice
{
    public int Addition(int a, int b) => a + b;
    public double Addition(double a, double b) => a + b;
}
```

Ici, `Addition()` existe sous deux formes : une pour les entiers, une pour les nombres à virgule.
C’est un **polymorphisme de compilation**, car la méthode utilisée est déterminée avant l’exécution.

---

### 2. Le polymorphisme dynamique (ou *par héritage*)

Ce type de polymorphisme se produit **à l’exécution**, grâce à la combinaison de l’héritage et des mots-clés `virtual`, `override` et `abstract`.
Une **référence de type parent** peut ainsi **pointer vers un objet de type enfant**, tout en appelant la version redéfinie d’une méthode.

```csharp
public class Ennemi
{
    public virtual void Attaquer()
    {
        Console.WriteLine("L’ennemi attaque !");
    }
}

public class Gobelin : Ennemi
{
    public override void Attaquer()
    {
        Console.WriteLine("Le gobelin lance une pierre !");
    }
}

public class Boss : Ennemi
{
    public override void Attaquer()
    {
        Console.WriteLine("Le boss invoque une explosion !");
    }
}
```

Et dans le programme :

```csharp
Ennemi[] ennemis = { new Gobelin(), new Boss() };

foreach (var e in ennemis)
    e.Attaquer();
```

**Sortie :**

```
Le gobelin lance une pierre !
Le boss invoque une explosion !
```

Bien que le tableau soit typé `Ennemi[]`, chaque élément réagit selon **sa classe concrète**.
C’est le **liage dynamique** (ou *late binding*).

---

## Polymorphisme via les interfaces

Le polymorphisme ne se limite pas à l’héritage : il fonctionne aussi avec les **interfaces**.
Une même référence d’interface peut manipuler des objets de différents types, tant qu’ils implémentent cette interface.

```csharp
public interface IArme
{
    void Attaquer();
}

public class Arc : IArme
{
    public void Attaquer() => Console.WriteLine("L’arc tire une flèche !");
}

public class Baton : IArme
{
    public void Attaquer() => Console.WriteLine("Le bâton lance un sort !");
}
```

```csharp
IArme[] armes = { new Arc(), new Baton() };

foreach (var arme in armes)
    arme.Attaquer();
```

Ce mécanisme est l’un des fondements du **principe d’inversion de dépendance** (un des principes SOLID), car il permet de travailler avec des **interfaces abstraites** plutôt qu’avec des classes concrètes.

---

## Avantages du polymorphisme

1. **Extensibilité**

    * De nouveaux types peuvent être ajoutés sans modifier le code existant.

2. **Réduction du couplage**

    * Le code dépend d’interfaces génériques plutôt que de classes spécifiques.

3. **Clarté et maintenance**

    * Les comportements spécifiques sont encapsulés dans les sous-classes.

4. **Réutilisabilité**

    * Une même structure de code peut s’appliquer à plusieurs types d’objets.

---

## Différence entre surcharge et redéfinition

| Type de polymorphisme        | Moment de résolution | Mécanisme                                                       | Mots-clés                         | Exemple                                           |
| ---------------------------- | -------------------- | --------------------------------------------------------------- | --------------------------------- | ------------------------------------------------- |
| **Statique (surcharge)**     | Compilation          | Plusieurs méthodes avec le même nom mais signatures différentes | Aucun mot-clé spécifique          | `Addition(int, int)` / `Addition(double, double)` |
| **Dynamique (redéfinition)** | Exécution            | Redéfinition d’une méthode héritée                              | `virtual`, `override`, `abstract` | `Attaquer()` dans `Ennemi`, `Gobelin`, `Boss`     |

---

## Exemple complet minimal

```csharp
public abstract class Forme
{
    public abstract double Aire();
}

public class Cercle : Forme
{
    public double Rayon;
    public Cercle(double r) => Rayon = r;
    public override double Aire() => Math.PI * Rayon * Rayon;
}

public class Rectangle : Forme
{
    public double Largeur, Hauteur;
    public Rectangle(double l, double h)
    {
        Largeur = l; Hauteur = h;
    }
    public override double Aire() => Largeur * Hauteur;
}
```

```csharp
Forme[] formes = { new Cercle(3), new Rectangle(4, 2) };

foreach (var f in formes)
    Console.WriteLine($"Aire : {f.Aire():0.00}");
```

**Sortie :**

```
Aire : 28.27
Aire : 8.00
```

Le polymorphisme permet ici de traiter des formes différentes (cercle, rectangle) via un même type abstrait (`Forme`), sans connaître leur nature exacte.

---

## Lien avec Unity

Le polymorphisme est omniprésent dans Unity :

* Toutes les classes de scripts héritent de `MonoBehaviour`, permettant au moteur d’appeler uniformément des méthodes comme `Start()`, `Update()`, `OnTriggerEnter()`, etc., sans savoir quel script concret les implémente.
* Les interfaces sont souvent utilisées pour gérer des comportements communs : par exemple `IDamageable`, `IInteractable`, ou `ISaveable`.
* On peut stocker différents objets implémentant une même interface dans une même collection (par exemple une liste d’objets interactifs) et les manipuler via des appels polymorphes.

Ce principe est fondamental pour concevoir des systèmes modulaires et évolutifs dans Unity.

---

## Références utiles

* [Microsoft Learn — Polymorphisme (C#)](https://learn.microsoft.com/fr-fr/dotnet/csharp/fundamentals/object-oriented/polymorphism)
* [Microsoft Learn — Interfaces et héritage polymorphique](https://learn.microsoft.com/fr-fr/dotnet/csharp/programming-guide/interfaces/)
* [Unity Manual — Scripting Concepts](https://docs.unity3d.com/Manual/ScriptingSection.html)
* Gamma, Helm, Johnson & Vlissides. *Design Patterns*, Addison-Wesley, 1994 (chap. 1 : réutilisation polymorphique).
