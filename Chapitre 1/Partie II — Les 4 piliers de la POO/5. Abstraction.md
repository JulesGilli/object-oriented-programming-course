# 5. Abstraction

## Objectif

Comprendre le principe d’**abstraction** en programmation orientée objet, son rôle dans la simplification du code, et comment l’implémenter en C# à l’aide des **classes abstraites** et des **interfaces**.

---

## Définition et explication

L’**abstraction** consiste à **masquer les détails d’implémentation** pour ne montrer que **l’essentiel** d’un objet ou d’un système.
Elle permet de **se concentrer sur ce que fait un objet** plutôt que sur **la manière dont il le fait**.

Autrement dit, l’abstraction définit **une interface claire** pour interagir avec un objet, tout en cachant la complexité technique qui se trouve derrière.
Ce principe favorise la **clarté**, la **modularité** et la **réutilisabilité** du code.

### Exemple conceptuel

Un utilisateur peut conduire une voiture sans connaître le fonctionnement interne du moteur.
De même, un développeur peut utiliser une méthode `LireFichier()` sans savoir comment le système de fichiers est manipulé en mémoire.
L’important est **le résultat attendu**, pas les détails internes.

---

## Abstraction vs Encapsulation

| Concept           | Objectif principal                                          | Métaphore                                               |
| ----------------- | ----------------------------------------------------------- | ------------------------------------------------------- |
| **Encapsulation** | Cacher les données internes et les protéger                 | Coffre-fort : les valeurs sont protégées à l’intérieur. |
| **Abstraction**   | Cacher les détails techniques et ne montrer que l’essentiel | Tableau de bord : on interagit sans voir le moteur.     |

Les deux principes sont complémentaires :

* **L’encapsulation** protège l’état interne de l’objet.
* **L’abstraction** simplifie son utilisation en ne révélant qu’une interface claire.

---

## Les outils d’abstraction en C#

En C#, l’abstraction s’exprime principalement à travers **les classes abstraites** et **les interfaces**.

### 1. Les classes abstraites

Une **classe abstraite** est un modèle général dont on ne peut pas créer directement d’instance.
Elle définit des **membres communs** à plusieurs classes, et peut contenir :

* des méthodes **avec implémentation** (code concret),
* et des méthodes **abstraites** (sans implémentation), que les classes dérivées devront obligatoirement définir.

```csharp
public abstract class Arme
{
    public string Nom;

    public abstract void Attaquer();
}
```

Une classe dérivée doit ensuite implémenter la méthode abstraite :

```csharp
public class Epee : Arme
{
    public override void Attaquer()
    {
        Console.WriteLine($"{Nom} tranche l’ennemi !");
    }
}
```

L’abstraction ici permet de **définir une structure commune** pour toutes les armes sans imposer leur logique interne.

---

### 2. Les interfaces

Une **interface** définit uniquement un **contrat de comportement** : un ensemble de méthodes ou propriétés qu’une classe doit implémenter.
Contrairement à une classe abstraite, une interface **ne contient pas d’état** (pas d’attributs) et ne fournit aucune implémentation.

```csharp
public interface ITransportable
{
    void Deplacer();
}
```

Une classe qui implémente cette interface s’engage à fournir une version concrète de la méthode :

```csharp
public class Personnage : ITransportable
{
    public void Deplacer()
    {
        Console.WriteLine("Le personnage se déplace.");
    }
}
```

L’interface définit **ce qu’une classe doit faire**, pas **comment elle le fait**.
C’est une **forme d’abstraction pure**.

---

## Avantages de l’abstraction

1. **Réduction de la complexité**

    * Les détails internes sont cachés derrière une interface claire et stable.

2. **Flexibilité**

    * Permet de modifier l’implémentation sans impacter le code client.

3. **Réutilisabilité et extensibilité**

    * Plusieurs classes différentes peuvent partager une même interface ou classe abstraite.

4. **Interopérabilité**

    * Favorise les architectures modulaires et le polymorphisme (traitement uniforme de différents objets).

---

## Exemple minimal

```csharp
public interface IArme
{
    void Attaquer();
}

public class Arc : IArme
{
    public void Attaquer()
    {
        Console.WriteLine("L’arc tire une flèche !");
    }
}

public class BatonMagique : IArme
{
    public void Attaquer()
    {
        Console.WriteLine("Le bâton lance un sort !");
    }
}
```

Ici, `IArme` définit **le contrat** : toute arme doit pouvoir attaquer.
Mais chaque implémentation (`Arc`, `BatonMagique`, etc.) est **libre de définir sa propre manière de le faire**.
Le code qui utilise une arme n’a donc pas besoin de connaître sa nature exacte.

---

## Lien avec Unity

L’abstraction est omniprésente dans le moteur Unity :

* **MonoBehaviour** agit comme une **classe de base abstraite** : on hérite de ses fonctionnalités sans voir son implémentation interne.
* De nombreuses interfaces du moteur (comme `IDamageable`, `IInteractable`, `ISerializationCallbackReceiver`) définissent des **contrats de comportement** que vous pouvez implémenter dans vos propres scripts.
* Exemple concret :

  ```csharp
  public interface IDamageable
  {
      void PrendreDegats(int montant);
  }

  public class Ennemi : MonoBehaviour, IDamageable
  {
      public void PrendreDegats(int montant)
      {
          // Implémentation spécifique à l'ennemi
      }
  }
  ```

  Cette approche permet à différents types d’objets (ennemis, joueurs, objets destructibles) de réagir uniformément à un système de dégâts, sans connaître leurs détails internes.

---

## Références utiles

* [Microsoft Learn — Classes et méthodes abstraites](https://learn.microsoft.com/fr-fr/dotnet/csharp/language-reference/keywords/abstract)
* [Microsoft Learn — Interfaces (C#)](https://learn.microsoft.com/fr-fr/dotnet/csharp/programming-guide/interfaces/)
* [Unity Scripting API — Interfaces courantes](https://docs.unity3d.com/ScriptReference/)
* Larman, Craig. *Applying UML and Patterns*, 3rd ed., Prentice Hall, 2004.
