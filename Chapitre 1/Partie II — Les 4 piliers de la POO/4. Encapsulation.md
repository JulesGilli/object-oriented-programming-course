# 4. Encapsulation

## Objectif

Comprendre le principe d’**encapsulation**, son rôle dans la protection de l’état interne d’un objet, et comment le mettre en œuvre en C# à l’aide des modificateurs d’accès et des propriétés.

---

## Définition et explication

L’**encapsulation** est le principe qui consiste à **protéger l’état interne d’un objet** en limitant l’accès direct à ses données.
Elle permet de **cacher l’implémentation interne** d’une classe et de **contrôler la manière dont ses attributs sont lus ou modifiés**.

L’idée est de ne pas exposer directement les champs d’un objet (par exemple `pointsDeVie`, `solde`, `position`), mais de passer par des **méthodes ou propriétés** pour y accéder.
Cela garantit que les données ne peuvent être modifiées qu’à travers des **règles bien définies**, ce qui améliore la **fiabilité** et la **sécurité** du code.

### Principe fondamental

> « Les données d’un objet doivent être protégées contre toute modification non autorisée ou incohérente. »

Ainsi, l’encapsulation sert à :

* Empêcher l’accès direct à des variables sensibles.
* Fournir une **interface publique stable** (les méthodes) tout en cachant les détails internes.
* Garantir que l’objet reste toujours dans un **état valide**.

---

## Mécanismes en C#

En C#, l’encapsulation repose principalement sur deux mécanismes :

### 1. Les modificateurs d’accès

Ils déterminent qui peut accéder à un membre (champ, méthode ou propriété).

| Modificateur | Accessible depuis          | Usage typique                         |
| ------------ | -------------------------- | ------------------------------------- |
| `public`     | Partout                    | Méthodes d’interface publique.        |
| `private`    | Uniquement dans la classe  | Protection des données internes.      |
| `protected`  | Classe et classes dérivées | Transmission contrôlée via héritage.  |
| `internal`   | Même assembly              | Contrôle d’accès au sein d’un projet. |

Les champs sont généralement `private`, tandis que les méthodes qui manipulent ces champs peuvent être `public`.

### 2. Les propriétés (`get` / `set`)

Une **propriété** agit comme un pont entre les champs privés et le monde extérieur.
Elle permet de **lire** (`get`) ou **écrire** (`set`) une valeur, tout en ajoutant de la logique de validation si nécessaire.

Exemple :

```csharp
public class CompteBancaire
{
    private decimal solde;

    public decimal Solde
    {
        get { return solde; }
        private set
        {
            if (value >= 0)
                solde = value;
        }
    }

    public void Deposer(decimal montant)
    {
        Solde += montant;
    }

    public bool Retirer(decimal montant)
    {
        if (montant <= Solde)
        {
            Solde -= montant;
            return true;
        }
        return false;
    }
}
```

Dans cet exemple :

* Le champ `solde` est **privé** : il ne peut pas être modifié directement.
* La propriété `Solde` permet uniquement de **consulter** le solde (lecture publique, écriture privée).
* Les méthodes `Deposer()` et `Retirer()` sont les **seuls moyens autorisés** pour modifier le solde.

Ce schéma garantit que le compte ne peut jamais avoir un solde négatif sans contrôle explicite.

---

## Avantages de l’encapsulation

1. **Protection des données**

    * Empêche les modifications arbitraires ou dangereuses.
    * Renforce la cohérence interne des objets.

2. **Abstraction**

    * Le code externe n’a pas besoin de connaître la logique interne (par exemple, comment le solde est calculé).

3. **Facilité de maintenance**

    * La structure interne peut changer sans impacter le code utilisateur, tant que l’interface publique reste la même.

4. **Contrôle et validation**

    * On peut ajouter des règles métier dans les accesseurs (`get`/`set`) pour empêcher des valeurs invalides.

---

## Exemple minimal

```csharp
public class Joueur
{
    private int pointsDeVie;

    public int PointsDeVie
    {
        get { return pointsDeVie; }
        set
        {
            if (value >= 0)
                pointsDeVie = value;
        }
    }

    public void SubirDegats(int degats)
    {
        PointsDeVie -= degats;
    }
}
```

Ici, même si `PointsDeVie` semble accessible publiquement, la logique interne empêche toute valeur négative : l’objet se protège lui-même.

---

## Lien avec Unity

L’encapsulation est omniprésente dans Unity :

* De nombreuses classes du moteur (comme `Transform`, `Rigidbody`, ou `Animator`) exposent des propriétés contrôlées via `get`/`set`.
* Par exemple, `transform.position` est une **propriété** — vous ne pouvez pas modifier directement les champs internes de `Transform`, mais vous pouvez changer la position via une interface sécurisée.
* Dans vos propres scripts, encapsuler vos champs avec `[SerializeField] private` est une pratique recommandée :

  ```csharp
  [SerializeField] private float vitesse;
  public float Vitesse => vitesse;
  ```

  Cela permet d’exposer la donnée à l’éditeur tout en empêchant sa modification directe par d’autres scripts.

L’encapsulation est donc un pilier central du modèle composant de Unity.

---

## Références utiles

* [Microsoft Learn — Propriétés (C#)](https://learn.microsoft.com/fr-fr/dotnet/csharp/programming-guide/classes-and-structs/properties)
* [Microsoft Learn — Modificateurs d’accès (C#)](https://learn.microsoft.com/fr-fr/dotnet/csharp/programming-guide/classes-and-structs/access-modifiers)
* [Unity Manual — Script Serialization](https://docs.unity3d.com/Manual/script-Serialization.html)
* Bloch, Joshua. *Effective Java* (chap. 4 : Encapsulation), Addison-Wesley, 2018 — un classique applicable par analogie au C#.
