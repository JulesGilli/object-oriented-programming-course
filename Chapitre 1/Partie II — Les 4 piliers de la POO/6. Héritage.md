# 6. Héritage

## Objectif

Comprendre le concept d’**héritage** en programmation orientée objet, son utilité dans la factorisation du code, et son implémentation en C# à travers les notions de classe de base, classe dérivée, et redéfinition de méthodes.

---

## Définition et explication

L’**héritage** est un mécanisme qui permet à une **classe dérivée** (ou *classe enfant*) de **réutiliser et d’étendre** le comportement d’une **classe de base** (ou *classe parent*).
Ce principe favorise la **factorisation du code** et la **spécialisation progressive** des comportements.

Une classe dérivée **hérite** :

* des **champs** (attributs) et **méthodes** publiques ou protégées de la classe de base,
* mais peut aussi **ajouter ses propres membres**, ou **modifier** certains comportements existants.

En C#, l’héritage se déclare à l’aide du symbole `:` après le nom de la classe.

---

### Exemple conceptuel

```csharp
public class Animal
{
    public void Respirer()
    {
        Console.WriteLine("L’animal respire.");
    }
}

public class Chien : Animal
{
    public void Aboyer()
    {
        Console.WriteLine("Le chien aboie !");
    }
}
```

Ici, `Chien` hérite de `Animal`.
Cela signifie que `Chien` possède automatiquement la méthode `Respirer()` en plus de sa propre méthode `Aboyer()` :

```csharp
var chien = new Chien();
chien.Respirer(); // Hérité de Animal
chien.Aboyer();   // Défini dans Chien
```

---

## Buts et avantages de l’héritage

1. **Réutilisation du code**
   Les classes partagent un comportement commun sans duplication.
   Exemple : `EnnemiVolant` et `EnnemiTerrestre` peuvent hériter de la même classe `Ennemi`.

2. **Spécialisation**
   Une classe dérivée peut enrichir ou adapter les comportements de la classe de base.

3. **Extensibilité**
   Il devient possible d’ajouter de nouveaux types sans modifier le code existant.

4. **Structure hiérarchique claire**
   Le code reflète la logique du domaine métier (par exemple : `Animal → Mammifère → Chien`).

---

## Héritage et modificateurs d’accès

Les membres d’une classe de base sont hérités **selon leur niveau d’accessibilité** :

| Modificateur | Hérité ?               | Accessible depuis la classe dérivée ?        |
| ------------ | ---------------------- | -------------------------------------------- |
| `public`     | Oui                    | Oui                                          |
| `protected`  | Oui                    | Oui (uniquement depuis les classes dérivées) |
| `private`    | Non                    | Non                                          |
| `internal`   | Oui (si même assembly) | Oui                                          |

Pour permettre à une classe dérivée de modifier un comportement hérité, C# utilise les mots-clés `virtual`, `override` et `base`.

---

## Redéfinition et extension de comportement

Une méthode dans la classe de base peut être déclarée comme **`virtual`** afin d’être redéfinie dans une classe dérivée à l’aide du mot-clé **`override`**.

```csharp
public class Animal
{
    public virtual void Crier()
    {
        Console.WriteLine("L’animal émet un son.");
    }
}

public class Chat : Animal
{
    public override void Crier()
    {
        Console.WriteLine("Le chat miaule.");
    }
}
```

Lorsqu’on appelle `Crier()` sur un objet `Chat`, c’est la version redéfinie qui est exécutée.

```csharp
Animal animal = new Chat();
animal.Crier(); // Affiche : "Le chat miaule."
```

> Ce comportement est la base du **polymorphisme d’exécution**, traité au point suivant.

---

### Utilisation du mot-clé `base`

Une classe dérivée peut également appeler la version d’origine d’une méthode ou d’un constructeur via le mot-clé `base`.

```csharp
public class Vehicule
{
    public Vehicule(string marque)
    {
        Console.WriteLine($"Véhicule de marque {marque}");
    }

    public virtual void Démarrer()
    {
        Console.WriteLine("Le véhicule démarre.");
    }
}

public class Voiture : Vehicule
{
    public Voiture(string marque) : base(marque)
    {
        Console.WriteLine("C’est une voiture.");
    }

    public override void Démarrer()
    {
        base.Démarrer(); // Appel à la méthode de la classe de base
        Console.WriteLine("La voiture roule !");
    }
}
```

Cet exemple illustre comment **étendre** un comportement existant au lieu de le remplacer totalement.

---

## Types d’héritage en C#

C# ne supporte que l’**héritage simple** entre classes (une seule classe de base par classe dérivée).
Cependant, une classe peut **implémenter plusieurs interfaces**, permettant de combiner différents comportements sans multiplier les classes parentes.

```csharp
public class Joueur : Personnage, IDamageable, ISaveable
{
    // Hérite de Personnage
    // Implémente deux interfaces
}
```

Ce modèle combine la **hiérarchie d’héritage** (classe de base) avec la **souplesse des interfaces** (multiples comportements).

---

## Bonnes pratiques

* **Favoriser la cohérence logique** : n’utiliser l’héritage que lorsqu’il existe une relation “est un(e)” (*is a*).
  Exemple : un `Chien` **est un** `Animal`, mais une `Voiture` **a un** `Moteur` → composition préférable.
* **Ne pas abuser de l’héritage** : trop de niveaux hiérarchiques complexifient la maintenance.
* **Utiliser `sealed`** pour empêcher l’héritage d’une classe lorsqu’il n’a pas de sens.

---

## Exemple complet minimal

```csharp
public class Animal
{
    public virtual void Crier() => Console.WriteLine("L’animal crie.");
}

public class Chien : Animal
{
    public override void Crier() => Console.WriteLine("Le chien aboie !");
}

public class Chat : Animal
{
    public override void Crier() => Console.WriteLine("Le chat miaule.");
}
```

```csharp
Animal[] animaux = { new Chien(), new Chat(), new Animal() };

foreach (var a in animaux)
    a.Crier();
```

**Sortie :**

```
Le chien aboie !
Le chat miaule.
L’animal crie.
```

Ce comportement illustre à la fois l’héritage et le polymorphisme dynamique (le prochain pilier).

---

## Lien avec Unity

L’héritage est un **fondement du modèle de script Unity** :

* Tous les scripts personnalisés héritent de la classe **`MonoBehaviour`**, qui fournit les méthodes de cycle de vie (`Start()`, `Update()`, `Awake()`, etc.).
* Vous pouvez créer vos propres hiérarchies : par exemple, une classe `Ennemi` de base, puis des classes dérivées comme `Gobelin`, `Orc`, ou `Boss`.
* L’héritage permet aussi de **partager des comportements communs** entre plusieurs entités sans dupliquer le code (par exemple, gestion de la santé, des dégâts, ou des animations).

Cependant, Unity encourage souvent à préférer la **composition** (via les composants attachés aux GameObjects) lorsque la relation “a un” est plus pertinente qu’une relation “est un”.

---

## Références utiles

* [Microsoft Learn — Héritage (C#)](https://learn.microsoft.com/fr-fr/dotnet/csharp/fundamentals/object-oriented/inheritance)
* [Microsoft Learn — virtual, override et base](https://learn.microsoft.com/fr-fr/dotnet/csharp/language-reference/keywords/override)
* [Unity Manual — Inheritance and Components](https://docs.unity3d.com/Manual/ComponentsAndInheritance.html)
* Gamma, Helm, Johnson & Vlissides. *Design Patterns: Elements of Reusable Object-Oriented Software*, Addison-Wesley, 1994.
