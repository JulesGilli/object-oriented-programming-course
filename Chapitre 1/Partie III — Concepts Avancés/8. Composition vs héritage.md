# 8. Composition vs Héritage

## Objectif

Comprendre la différence entre **composition** et **héritage**, savoir quand utiliser l’un ou l’autre, et pourquoi la composition est souvent préférable pour construire des architectures flexibles et modulaires.

---

## Définition et explication

L’**héritage** et la **composition** sont deux approches permettant de réutiliser du code et de structurer des relations entre classes.

* **Héritage** : une classe dérive d’une autre pour en hériter les membres (relation “est un” — *is a*).
* **Composition** : une classe contient une instance d’une autre classe pour utiliser ses fonctionnalités (relation “a un” — *has a*).

Ces deux techniques répondent à des besoins différents :

* L’héritage favorise la **spécialisation** : créer des variantes d’un même concept.
* La composition favorise la **combinaison** : assembler des comportements indépendants.

---

## L’héritage (rappel)

L’héritage permet de créer une **hiérarchie de classes** où les classes dérivées étendent ou redéfinissent les fonctionnalités de la classe de base.

```csharp
public class Vehicule
{
    public virtual void Deplacer()
    {
        Console.WriteLine("Le véhicule se déplace.");
    }
}

public class Voiture : Vehicule
{
    public override void Deplacer()
    {
        Console.WriteLine("La voiture roule.");
    }
}
```

Relation :

> Une `Voiture` **est un** `Véhicule`.

L’héritage est donc utile lorsque les classes partagent un **comportement commun naturel** et que la hiérarchie est stable.

---

## La composition

La **composition** consiste à créer des objets complexes en **assemblant d’autres objets** qui fournissent des fonctionnalités spécifiques.
Plutôt que d’hériter d’une classe, on **l’instancie comme un champ** à l’intérieur d’une autre.

```csharp
public class Moteur
{
    public void Demarrer()
    {
        Console.WriteLine("Le moteur démarre.");
    }
}

public class Voiture
{
    private Moteur moteur = new Moteur();

    public void Demarrer()
    {
        moteur.Demarrer();
        Console.WriteLine("La voiture est en marche.");
    }
}
```

Relation :

> Une `Voiture` **a un** `Moteur`.

Cette approche favorise la **modularité** et la **réutilisation** : un même moteur pourrait être utilisé dans une `Moto`, un `Bateau` ou un `Avion`, sans lien hiérarchique entre ces classes.

---

## Comparaison entre héritage et composition

| Critère                     | Héritage                    | Composition                       |
| --------------------------- | --------------------------- | --------------------------------- |
| Relation logique            | “Est un” (*is a*)           | “A un” (*has a*)                  |
| Type de lien                | Fortement couplé            | Faiblement couplé                 |
| Réutilisation du code       | Par extension               | Par assemblage                    |
| Flexibilité                 | Limitée (hiérarchie rigide) | Élevée (combinaisons libres)      |
| Changement d’implémentation | Difficile                   | Facile (on remplace un composant) |
| Exemple                     | `Chien` hérite de `Animal`  | `Joueur` contient une `Arme`      |

La composition est donc souvent **préférée à l’héritage** dans les architectures modernes, car elle limite le couplage et facilite l’évolution du code.

---

## Quand préférer la composition

1. **Quand la relation n’est pas une vraie spécialisation**

    * Si une classe “utilise” une autre, mais n’est pas conceptuellement une de ses variantes.
    * Exemple : un `Joueur` **a une** `Arme`, mais **n’est pas une** `Arme`.

2. **Quand on veut éviter une hiérarchie complexe**

    * Trop d’héritage conduit à des dépendances fortes et des comportements difficiles à maintenir.

3. **Quand on souhaite favoriser la réutilisation**

    * Un même composant peut être injecté dans plusieurs classes.

4. **Quand la flexibilité est primordiale**

    * On peut remplacer un composant sans modifier la classe principale (principe d’injection de dépendances).

---

## Exemple concret

### Version avec héritage (fort couplage)

```csharp
public class Joueur : Arme
{
    public void Attaquer()
    {
        Utiliser();
    }
}
```

Cette conception suppose que le joueur **est** une arme, ce qui est incohérent dans le modèle.
De plus, si l’on veut que le joueur change d’arme, il faudrait modifier la hiérarchie.

### Version avec composition (souple et réaliste)

```csharp
public class Arme
{
    public void Utiliser() => Console.WriteLine("L’arme attaque !");
}

public class Joueur
{
    private Arme arme;

    public Joueur(Arme arme)
    {
        this.arme = arme;
    }

    public void Attaquer()
    {
        arme.Utiliser();
    }
}
```

Ici, le joueur **possède** une arme, mais peut facilement en changer :

```csharp
var epee = new Arme();
var joueur = new Joueur(epee);
joueur.Attaquer();
```

Ce modèle est plus réaliste, plus flexible, et plus conforme aux bonnes pratiques d’architecture.

---

## Héritage et composition dans Unity

Unity illustre parfaitement la différence entre héritage et composition :

* Les scripts dérivent de `MonoBehaviour` → **héritage** : cela fournit un cadre de base (cycle de vie, gestion du comportement).
* Mais un GameObject est composé de **plusieurs composants indépendants** (Transform, Rigidbody, Collider, Script, etc.) → **composition**.

Ce modèle favorise la **modularité** :

> Un GameObject n’hérite pas de plusieurs comportements, il **les combine** en ajoutant des composants.

Ainsi, la conception d’Unity repose fondamentalement sur le principe de **“composition over inheritance”** :
plutôt que de créer de longues hiérarchies de classes, on assemble des comportements indépendants.

---

## Bonnes pratiques

* Utiliser l’héritage uniquement lorsque la relation “est un(e)” est **logiquement justifiée**.
* Préférer la composition pour construire des objets **modulaires et réutilisables**.
* Dans Unity, concevoir vos systèmes autour de **composants indépendants** plutôt que d’arborescences de classes.
* Coupler la composition avec des **interfaces** pour obtenir une architecture souple (principe *Interface Segregation* du modèle SOLID).

---

## Références utiles

* [Microsoft Learn — Héritage (C#)](https://learn.microsoft.com/fr-fr/dotnet/csharp/fundamentals/object-oriented/inheritance)
* [Unity Manual — GameObjects and Components](https://docs.unity3d.com/Manual/GameObjects.html)
* [Refactoring Guru — Composition over Inheritance](https://refactoring.guru/fr/design-patterns/composition-over-inheritance)
* Fowler, Martin. *Refactoring: Improving the Design of Existing Code*, Addison-Wesley, 2018.
