# 10. Couplage et Cohésion

## Objectif

Comprendre les notions de **couplage** et de **cohésion**, savoir identifier un design trop dépendant ou mal structuré, et apprendre à appliquer le **principe de responsabilité unique (SRP)** pour concevoir un code modulaire, clair et maintenable.

---

## Définition et explication

En conception orientée objet, **le couplage** et **la cohésion** sont deux indicateurs essentiels de la **qualité structurelle** d’un logiciel.

* **Cohésion** : mesure à quel point les éléments d’une même classe ou d’un même module travaillent ensemble pour une **même responsabilité**.
* **Couplage** : mesure le **degré de dépendance** entre différentes classes ou modules.

Un bon design se caractérise par :

* une **forte cohésion** (chaque classe a une mission claire et bien définie),
* et un **faible couplage** (les classes communiquent entre elles sans dépendances excessives).

---

## La cohésion

Une classe cohésive se concentre sur **une seule responsabilité**.
Ses méthodes et attributs contribuent à un **même objectif fonctionnel**.

Exemple d’une classe à **faible cohésion** (mauvaise pratique) :

```csharp
public class GestionJeu
{
    public void SauvegarderPartie() { /* ... */ }
    public void CalculerScore() { /* ... */ }
    public void JouerMusique() { /* ... */ }
}
```

Ici, `GestionJeu` fait à la fois de la logique de jeu, du son et de la sauvegarde — des responsabilités sans lien direct.

Exemple d’une classe à **forte cohésion** :

```csharp
public class GestionScore
{
    public void CalculerScore() { /* ... */ }
    public void AfficherScore() { /* ... */ }
}
```

Chaque classe a une responsabilité unique et claire.

### Principe associé : SRP — *Single Responsibility Principle*

> Une classe ne devrait avoir qu’une seule raison de changer.
> (C’est le premier principe du modèle **SOLID**, défini par Robert C. Martin.)

Une forte cohésion rend le code **plus clair, plus testable** et **plus facile à faire évoluer**.

---

## Le couplage

Le **couplage** décrit à quel point une classe dépend d’autres classes pour fonctionner.
Un **couplage fort** rend le code difficile à modifier : tout changement dans une classe peut casser le comportement d’autres classes.
Un **couplage faible**, au contraire, limite les dépendances et rend les modules indépendants.

### Exemple de couplage fort :

```csharp
public class Joueur
{
    private Inventaire inventaire = new Inventaire();

    public void AjouterObjet(string objet)
    {
        inventaire.Ajouter(objet);
    }
}
```

Ici, `Joueur` crée directement une instance de `Inventaire`.
Il dépend donc de son implémentation concrète — impossible de remplacer ou de tester sans elle.

### Exemple de couplage faible (via abstraction) :

```csharp
public interface IInventaire
{
    void Ajouter(string objet);
}

public class Joueur
{
    private IInventaire inventaire;

    public Joueur(IInventaire inventaire)
    {
        this.inventaire = inventaire;
    }

    public void AjouterObjet(string objet)
    {
        inventaire.Ajouter(objet);
    }
}
```

Le joueur dépend maintenant d’une **interface**, pas d’une classe spécifique.
Cette approche permet d’injecter n’importe quelle implémentation (`InventaireBasique`, `InventaireAvancé`, etc.) et de tester plus facilement le comportement.

---

## Relations entre couplage et cohésion

Ces deux principes sont liés :

| Type de relation                     | Description                                                        | Impact                                |
| ------------------------------------ | ------------------------------------------------------------------ | ------------------------------------- |
| **Forte cohésion / Faible couplage** | Idéal : chaque module fait une chose, et dépend peu des autres.    | Code maintenable, évolutif, testable. |
| **Faible cohésion / Fort couplage**  | Mauvais : les classes font trop de choses et sont interconnectées. | Code fragile, difficile à modifier.   |

Une architecture bien conçue vise toujours à **maximiser la cohésion** et **minimiser le couplage**.

---

## Techniques pour réduire le couplage

1. **Utiliser des interfaces** pour découpler les dépendances directes.
2. **Appliquer l’injection de dépendances (DI)** pour fournir les objets dont une classe a besoin sans les instancier elle-même.
3. **Limiter la visibilité** des membres internes (`private`, `internal`).
4. **Centraliser les communications** via des gestionnaires ou des événements (pattern *Observer*).
5. **Utiliser des événements ou délégués** pour éviter les références directes entre classes.

---

## Exemple d’application : refactorisation

### Avant (couplage fort, faible cohésion)

```csharp
public class GestionJeu
{
    public void JouerMusique() { /* ... */ }
    public void SauvegarderPartie() { /* ... */ }
    public void CalculerScore() { /* ... */ }
}
```

### Après (forte cohésion, faible couplage)

```csharp
public class GestionAudio { public void JouerMusique() { /* ... */ } }
public class GestionSauvegarde { public void SauvegarderPartie() { /* ... */ } }
public class GestionScore { public void CalculerScore() { /* ... */ } }

public class GestionJeu
{
    private GestionAudio audio;
    private GestionSauvegarde sauvegarde;
    private GestionScore score;

    public GestionJeu(GestionAudio a, GestionSauvegarde s, GestionScore sc)
    {
        audio = a;
        sauvegarde = s;
        score = sc;
    }
}
```

Chaque classe se concentre sur sa propre responsabilité, et les dépendances sont injectées — le code devient **modulaire et testable**.

---

## Lien avec Unity

Unity repose sur une **architecture à faible couplage et forte cohésion** :

* Chaque **composant** (`Rigidbody`, `Collider`, `AudioSource`, `Script`, etc.) a une responsabilité unique.
* Les composants interagissent via des **références publiques**, des **événements** ou des **interfaces**, sans dépendre directement des implémentations internes.

Exemple :

```csharp
public interface IDamageable
{
    void PrendreDegats(int montant);
}

public class Ennemi : MonoBehaviour, IDamageable
{
    public void PrendreDegats(int montant)
    {
        // Logique spécifique à l’ennemi
    }
}

public class Projectile : MonoBehaviour
{
    private void OnCollisionEnter(Collision collision)
    {
        var cible = collision.gameObject.GetComponent<IDamageable>();
        cible?.PrendreDegats(10);
    }
}
```

Ici :

* `Projectile` ne dépend pas du type concret d’objet touché (ennemi, joueur, objet destructible).
* L’interaction se fait via l’interface `IDamageable` → couplage faible, cohésion forte.

C’est un exemple parfait de **bonne architecture orientée objet** dans Unity.

---

## Références utiles

* [Microsoft Learn — Architecture logicielle en couches](https://learn.microsoft.com/fr-fr/azure/architecture/guide/architecture-styles/layered)
* [Refactoring Guru — Couplage et Cohésion](https://refactoring.guru/fr/refactoring/smells/coupling-cohesion)
* [Unity Manual — Component-based Design](https://docs.unity3d.com/Manual/Components.html)
* Martin, Robert C. *Clean Architecture: A Craftsman’s Guide to Software Structure and Design*, Prentice Hall, 2017.
