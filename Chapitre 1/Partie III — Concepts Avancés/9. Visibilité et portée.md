# 9. Visibilité et portée

## Objectif

Comprendre les notions de **visibilité** et de **portée** en C#, savoir utiliser correctement les modificateurs d’accès pour protéger et organiser le code, et appliquer ces principes dans une architecture orientée objet (notamment sous Unity).

---

## Définition et explication

La **visibilité** détermine **qui peut accéder à un élément** du code (classe, attribut, méthode, propriété, etc.).
La **portée** (ou *scope*) définit **où** un élément est valide et peut être utilisé dans le programme.

Ces deux notions assurent la **séparation des responsabilités**, la **protection des données**, et la **lisibilité** du code.

Bien maîtriser la visibilité et la portée permet de :

* éviter les accès involontaires à des éléments internes,
* limiter les effets de bord,
* clarifier l’architecture logicielle,
* et faciliter la maintenance du projet.

---

## Les modificateurs d’accès en C#

Les **modificateurs d’accès** contrôlent la visibilité des membres et des classes dans un programme C#.

| Modificateur         | Portée                                           | Description                                              | Exemple d’usage                             |
| -------------------- | ------------------------------------------------ | -------------------------------------------------------- | ------------------------------------------- |
| `public`             | Partout                                          | Accessible depuis n’importe quel code.                   | Méthodes d’API, points d’entrée publics.    |
| `private`            | À l’intérieur de la classe uniquement            | C’est le niveau de protection maximal.                   | Attributs internes, logique cachée.         |
| `protected`          | Dans la classe et ses dérivées                   | Permet l’accès pour l’héritage.                          | Méthodes à redéfinir dans des sous-classes. |
| `internal`           | Dans le même assembly (projet)                   | Visible à l’intérieur du projet, mais pas à l’extérieur. | Classes de service internes.                |
| `protected internal` | Dans le même assembly ou classes dérivées        | Combine `protected` et `internal`.                       | Méthodes héritables dans un même projet.    |
| `private protected`  | Classe et classes dérivées dans le même assembly | Version plus restrictive que `protected internal`.       | Contrôle fin dans des bibliothèques.        |

### Exemple d’utilisation simple :

```csharp
public class Joueur
{
    private int pointsDeVie = 100;
    protected int niveau = 1;
    public string Nom { get; set; }

    public void AfficherInfos()
    {
        Console.WriteLine($"{Nom} - Niveau {niveau} - PV : {pointsDeVie}");
    }
}
```

Ici :

* `pointsDeVie` est **privé** : accessible uniquement dans `Joueur`.
* `niveau` est **protégé** : accessible dans `Joueur` et ses sous-classes.
* `Nom` est **public** : accessible depuis n’importe quelle autre classe.

---

## Portée des variables

En C#, la **portée** d’une variable dépend de **l’endroit où elle est déclarée**.

| Type de variable      | Portée                              | Description                                                         |
| --------------------- | ----------------------------------- | ------------------------------------------------------------------- |
| Variable locale       | Méthode ou bloc (`if`, `for`, etc.) | N’existe que dans le bloc où elle est déclarée.                     |
| Champ de classe       | Dans toute la classe                | Accessible par toutes les méthodes de la classe (selon visibilité). |
| Variable de paramètre | Méthode                             | Accessible uniquement pendant l’exécution de la méthode.            |
| Variable statique     | Portée globale à la classe          | Partagée par toutes les instances.                                  |

Exemple :

```csharp
public class Exemple
{
    private int compteur = 0; // Champ de classe

    public void Compter()
    {
        int local = 10; // Variable locale
        compteur += local;
        Console.WriteLine(compteur);
    }
}
```

La variable `local` n’existe que pendant l’exécution de `Compter()`, tandis que `compteur` est conservée dans l’objet.

---

## Portée dans les blocs de code

Les blocs de code (`{ ... }`) délimitent la durée de vie et la visibilité des variables locales.
Une variable déclarée dans un bloc **n’est pas accessible** à l’extérieur de celui-ci.

```csharp
if (true)
{
    int x = 10;
    Console.WriteLine(x);
}
// Console.WriteLine(x);  // Erreur : x n'existe plus ici
```

Cela évite les interférences entre variables et garantit un **contrôle précis de la mémoire**.

---

## Bonnes pratiques de visibilité et de portée

1. **Appliquer le principe du moindre privilège**

    * Toujours choisir le niveau de visibilité **le plus restrictif** possible.
    * N’exposer en `public` que ce qui est nécessaire à l’extérieur de la classe.

2. **Encapsuler les données internes**

    * Utiliser des propriétés (`get`/`set`) pour contrôler l’accès aux champs privés.

3. **Éviter les variables globales**

    * Elles augmentent le couplage et rendent le débogage plus complexe.

4. **Limiter la portée des variables locales**

    * Déclarer une variable **au plus près de son utilisation**.

5. **Soigner la cohérence interne**

    * Une classe doit offrir une interface publique claire et un comportement interne cohérent.

---

## Exemple complet

```csharp
public class CompteBancaire
{
    private decimal solde; // Donnée interne protégée

    public string Titulaire { get; private set; } // Lecture publique, écriture privée

    public CompteBancaire(string titulaire, decimal soldeInitial)
    {
        Titulaire = titulaire;
        solde = soldeInitial;
    }

    public void Deposer(decimal montant)
    {
        if (montant > 0)
            solde += montant;
    }

    public decimal ConsulterSolde()
    {
        return solde;
    }
}
```

Ici :

* Le champ `solde` est **privé** → impossible à modifier directement.
* `Titulaire` a un `get` public et un `set` privé → lisible mais non modifiable.
* Les opérations (`Deposer`, `ConsulterSolde`) sont **publiques** → elles définissent l’interface autorisée.

---

## Lien avec Unity

Dans Unity, la visibilité joue un rôle essentiel dans la conception des scripts :

* Les **champs publics** apparaissent dans l’inspecteur, mais sont modifiables par d’autres scripts.
* Les **champs privés** marqués `[SerializeField]` sont visibles dans l’éditeur mais restent protégés dans le code.

  ```csharp
  [SerializeField] private float vitesse = 5f;
  public float Vitesse => vitesse;
  ```
* Les méthodes `public` (comme `TakeDamage()` ou `Move()`) définissent **l’interface de communication** entre composants.

L’utilisation judicieuse des modificateurs d’accès permet de **mieux structurer les interactions entre scripts** et d’éviter les dépendances non maîtrisées dans les projets Unity.

---

## Références utiles

* [Microsoft Learn — Modificateurs d’accès (C#)](https://learn.microsoft.com/fr-fr/dotnet/csharp/programming-guide/classes-and-structs/access-modifiers)
* [Microsoft Learn — Étendue et durée de vie des variables](https://learn.microsoft.com/fr-fr/dotnet/csharp/fundamentals/program-structure/variables)
* [Unity Manual — Script Serialization](https://docs.unity3d.com/Manual/script-Serialization.html)
* McConnell, Steve. *Code Complete, 2nd Edition*, Microsoft Press, 2004 — chap. 5 : “Designing for Change”.
